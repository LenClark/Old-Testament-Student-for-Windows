using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;

namespace OldTestamentStudent
{
    class classSearch
    {
        /*==================================================================================================================*
         *                                                                                                                  *
         *                                                classSearch                                                       *
         *                                                ===========                                                       *
         *                                                                                                                  *
         *  All methods relating to performing and managing the search function.                                            *
         *                                                                                                                  *
         *  Since the processing is quite convoluted, this summary constitutes a road-map of methods.                       *
         *                                                                                                                  *
         *  Following the more obvious, global variables, we define:                                                        *
         *    a) searchThread: what will be a background thread performing the actual search;                               *
         *    b) definition of a number of delegates                                                                        *
         *    c) the procedures that implement the delegates.                                                               *
         *  These are:                                                                                                      *
         *                                                                                                                  *
         *     Delegate                    Related Procedure                                                                *
         *     --------                    -----------------                                                                *
         *                                                                                                                  *
         *   performGroupboxAddition       addGroupbox                                                                      *
         *   performCheckboxAddition       addCheckbox                                                                      *
         *   performToolStripMessage       displayToolStripMessage     Display messages in the tool bar of the search area  *
         *   controlMTBaseSearch                                                                                            *
         *   controlLXXBaseSearch                                                                                           *
         *                                                                                                                  *
         *  These are followed by:                                                                                          *
         *                                                                                                                  *
         *   classSearch                   The initialising method for the class.                                           *
         *                                 Slave methods:                                                                   *
         *                                   searchOptionCheckedChanged         Called when a checkbox value is changed     *
         *                                                                                                                  *
         *  Other "setup" procedures are generated by buttons in the lower right Search tabs.  These are:                   *
         *                                                                                                                  *
         *     Form Button                           Procedure                                                              *
         *     -----------                           ---------                                                              *
         *                                                                                                                  *
         *   Main menu - Set Search Details       searchSetup                                                               *
         *                                          slave method:  hideOrShowAdvancedSearch                                 *
         *   Advanced Search button               setSearchType                                                             *
         *                                                                                                                  *
         *  The main form class will call the following method when either of the "Perform Search" buttons are clicked:     *
         *                                                                                                                  *
         *   controlSearch                                                                                                  *
         *                                                                                                                  *
         *  This, in turn, will call the following background task:                                                         *
         *                                                                                                                  *
         *   threadControl                                                                                                  *
         *                                                                                                                  *
         *  From this point on the background sequence will be as follows:                                                  *
         *                                                                                                                  *
         *         Masoretic Text (currentVersion = 0)                       Septuagint (currentVersion = 1)                *
         *         -----------------------------------                       -------------------------------                *
         *                                                                                                                  *
         *       mtBaseSearch  ->                                         lxxBaseSearch ->                                  *
         *          initialMTMatchProcessing                              initialLXXMatchProcessing                         *
         *          primaryMTScan                                         primaryLXXScan                                    *
         *          secondaryMTScan                                       secondaryLXXScan                                  *
         *          isThereAnMTMatch -> removeNonConsonents               isThereAnLXXMatch                                 *
         *          mtVerifyWord -> getStrongRefs                         lxxVerifyWord                                     *
         *          displayMTResults                                      displayLXXResults                                 *
         *                                                                                                                  *
         *                                                                                                                  *
         *                                                                                                                  *
         *  The following methods are used in the display processing by both MT and LXX:                                    *
         *                                                                                                                  *
         *    initialSetupOfRText      initial setup of a created RichTextBox                                               *
         *    getNewRTXHeight          Get the height of the text written to a RichTextBox                                  *
         *    resetRTX                 Reset the height of both RichTextBoxes in a given row                                *
         *                                                                                                                  *
         *==================================================================================================================*/

        const int col1Width = 200, flowSpacer = 30;

        bool isSearchSuccessful = false, isWordGiven, isSWordGiven;
        int noOfMatchingVerses, noOfMatchingLXXVerses, currentVersion, currentSearchType, matchType = 0, noOfRTXLines, noOfAllMatches = 0;

        SortedList<int, classMTPrimaryResult> listOfMTPrimaryResults = new SortedList<int, classMTPrimaryResult>();
        SortedList<int, classLXXPrimaryResult> listOfLXXPrimaryResults = new SortedList<int, classLXXPrimaryResult>();
        SortedList<int, classMTSearchMatches> allMatches = new SortedList<int, classMTSearchMatches>();
        SortedList<int, classLXXSearchMatches> allLXXMatches = new SortedList<int, classLXXSearchMatches>();
        List<String> booksToInclude = new List<string>();
        SortedSet<int> strongRefs;
        SortedSet<int> SecondStrongRefs;
        frmMain mainForm;
        classGlobal globalVars;
        classMTText mtText;
        classLXXText lxxText;
        classHebLexicon hebrewLexicon;
        classGkLexicon greekLexicon;
        classGreekOrthography greekProcs;
        classNote noteProcs;

        Thread searchThread;

        private delegate void performGroupboxAddition(GroupBox targetGroupbox, GroupBox newGroupbox);
        private delegate void performCheckboxAddition(GroupBox targetGroupbox, CheckBox newCheckbox);
        private delegate void performToolStripMessage(StatusStrip sStripSearch, int toolStripIndex, String message);
        private delegate void performVisibilityCheck(Label targetLabel);
        private delegate void performTabSelection(TabControl targetTab, int indexNo);
        private delegate void performPanelClear(FlowLayoutPanel targetPanel);
        private delegate void performControlPlacement(FlowLayoutPanel targetPanel, RichTextBox newTextBox);
        private delegate void performRichTextBoxUpdate(RichTextBox rtxtTarget, int actionCode, Object actionData);
        private delegate void performRichTextBoxHeightDetermination(RichTextBox rtxCurrent, Font fontUsed);
        private delegate void performRichTextBoxHeightAdjustment(RichTextBox rtxtCurrent, int newHeight);
        private delegate void performHideStopButton();
        private delegate void performTabControlItemSelection(TabControl targetTabControl, int itemIndex);
        private delegate void controlMTBaseSearch(int searchType, int matchType, int pBook, String pChap, String pVerse, int pSeq,
            int sBook, String sChap, String sVerse, int sSeq, String pWord, String sWord, int searchSpan, bool exclude_include);
        private delegate void controlLXXBaseSearch(int searchType, int matchType, int pBook, String pChap, String pVerse, int pSeq,
            int sBook, String sChap, String sVerse, int sSeq, String pWord, String sWord, int searchSpan, bool exclude_include);

        private void addGroupbox(GroupBox targetGroupbox, GroupBox newGroupbox)
        {
            targetGroupbox.Controls.Add(newGroupbox);
        }

        private void addCheckbox(GroupBox targetGroupbox, CheckBox newCheckbox)
        {
            targetGroupbox.Controls.Add(newCheckbox);
        }

        private void displayToolStripMessage(StatusStrip sStripSearch, int toolStripIndex, String message)
        {
            ToolStripStatusLabel toolStriplabel;

            toolStriplabel = (ToolStripStatusLabel)sStripSearch.Items[toolStripIndex];
            toolStriplabel.Text = message;
        }

        private void checkLabelVisibility(Label targetLabel)
        {
            if (targetLabel.Visible) currentSearchType = 2;
            else currentSearchType = 1;
        }

        private void selectTab(TabControl targetTab, int indexNo)
        {
            targetTab.SelectedIndex = indexNo;
        }

        private void clearFlowPanel(FlowLayoutPanel targetPanel)
        {
            targetPanel.Controls.Clear();
        }

        private void addTextBoxToPanel(FlowLayoutPanel targetPanel, RichTextBox newTextBox)
        {
            targetPanel.Controls.Add(newTextBox);
        }

        private void hideStopButton()
        {
            Button stopButton;

            stopButton = (Button)globalVars.getGroupedControl(globalVars.ButtonCode, 2);
            stopButton.Visible = false;
        }

        private void selectTabControlItem(TabControl targetTabControl, int itemIndex)
        {
            targetTabControl.SelectedIndex = itemIndex;
        }


        private void updateRichTextBox(RichTextBox rtxtTarget, int actionCode, Object actionData)
        {
            /*---------------------------------------------------------------------------------------------*
             *                                                                                             *
             *                                   updateRichTextBox                                         *
             *                                   -----------------                                         *
             *                                                                                             *
             *  This delegate slave is a little more generic than many of the others, so needs some        *
             *    explanation                                                                              *
             *                                                                                             *
             *    actionCode                significance                         actionData                *
             *    ----------                ------------                         ----------                *
             *                                                                                             *
             *        1         Sets the font of subsequent text                   Font                    *
             *        2         Sets the colour of subsequent text                 Color                   *
             *        3         Adds text to the specified RichTextBox             String                  *
             *                                                                                             *
             *---------------------------------------------------------------------------------------------*/

            switch( actionCode )
            {
                case 1: rtxtTarget.SelectionFont = (Font)actionData; break;
                case 2: rtxtTarget.SelectionColor = (Color)actionData; break;
                case 3: rtxtTarget.SelectedText = (String)actionData; break;
            }
        }

        public classSearch( frmMain callingForm, classGlobal inGlobal, classHebLexicon inHebLex, classGkLexicon inGkLex, classGreekOrthography inGkProcs, 
            classMTText inMTText, classLXXText inLXXText, classNote inNote)
        {
            int idx, tagCount = 0;
            int[] chkBoxPstn = { 10, 27, 58, 77, 95, 112, 129 };
            GroupBox gbBooks, targetGroupbox;
            CheckBox chkInTransit;

            mainForm = callingForm;
            globalVars = inGlobal;
            hebrewLexicon = inHebLex;
            greekLexicon = inGkLex;
            greekProcs = inGkProcs;
            mtText = inMTText;
            lxxText = inLXXText;
            noteProcs = inNote;

            // Configure booklist for MT
            gbBooks = new GroupBox();
            gbBooks.Left = 122;
            gbBooks.Top = 31;
            gbBooks.Width = 115;
            gbBooks.Height = 131;
            gbBooks.Text = "";
            targetGroupbox = (GroupBox)globalVars.getGroupedControl(globalVars.GroupboxCode, 0);
            targetGroupbox.Invoke(new performGroupboxAddition(addGroupbox), targetGroupbox, gbBooks);
            for (idx = 0; idx < globalVars.NoOfMTBookGroups; idx++)
            {
                chkInTransit = new CheckBox();
                chkInTransit.Left = 9;
                chkInTransit.Top = chkBoxPstn[idx];
                chkInTransit.Text = globalVars.CategoryName[idx];
                chkInTransit.AutoSize = true;
                chkInTransit.Tag = tagCount++;
                chkInTransit.CheckedChanged += searchOptionCheckedChanged;
                gbBooks.Controls.Add(chkInTransit);
                gbBooks.Invoke(new performCheckboxAddition(addCheckbox), gbBooks, chkInTransit);
                globalVars.ChkMTBooks[idx] = chkInTransit;
            }

            // Configure booklist for LXX
            gbBooks = new GroupBox();
            gbBooks.Left = 122;
            gbBooks.Top = 31;
            gbBooks.Width = 115;
            gbBooks.Height = 148;
            gbBooks.Tag = tagCount++;
            gbBooks.Text = "";
            targetGroupbox = (GroupBox)globalVars.getGroupedControl(globalVars.GroupboxCode, 1);
            targetGroupbox.Invoke(new performGroupboxAddition(addGroupbox), targetGroupbox, gbBooks);
            for (idx = 0; idx < globalVars.NoOfLXXBookGroups; idx++)
            {
                chkInTransit = new CheckBox();
                chkInTransit.Left = 9;
                chkInTransit.Top = chkBoxPstn[idx];
                chkInTransit.Text = globalVars.CategoryName[idx];
                chkInTransit.AutoSize = true;
                chkInTransit.Tag = tagCount++;
                chkInTransit.CheckedChanged += searchOptionCheckedChanged;
                gbBooks.Controls.Add(chkInTransit);
                gbBooks.Invoke(new performCheckboxAddition(addCheckbox), gbBooks, chkInTransit);
                globalVars.ChkLXXBooks[idx] = chkInTransit;
            }
        }

        public void searchOptionCheckedChanged(object sender, EventArgs e)
        {
            /*=====================================================================================*
             *                                                                                     *
             *                           searchOptionCheckedChanged                                *
             *                           ==========================                                *
             *                                                                                     *
             *  This is all about managing selection of the radio buttons and check boxes that     *
             *    limit/activate groups of books.  A key control are the following constants and   *
             *    their explanations are:                                                          *
             *                                                                                     *
             *  To know the category to which a specific book belongs, we need to look at category *
             *    in the Book class                                                                *
             *                                                                                     *
             *=====================================================================================*/

            bool isMT = true;
            int idx;
            SortedSet<int> checkedCategories = new SortedSet<int>();
            CheckBox currentCheckbox;
            ListBox targetListbox;

            currentCheckbox = (CheckBox)sender;
            if (Convert.ToInt32(currentCheckbox.Tag) >= globalVars.NoOfMTBookGroups) isMT = false;
            if (isMT)
            {
                classMTBook currentBook;
                for (idx = 0; idx < globalVars.NoOfMTBookGroups; idx++)
                {
                    if (globalVars.ChkMTBooks[idx].Checked) checkedCategories.Add(idx + 1);
                }
                targetListbox = (ListBox)globalVars.getGroupedControl(globalVars.ListBoxCode, 0);
                targetListbox.Items.Clear();
                for (idx = 0; idx < globalVars.NoOfMTBooks; idx++)
                {
                    globalVars.MtBookList.TryGetValue(idx, out currentBook);
                    if (!checkedCategories.Contains(currentBook.Category)) targetListbox.Items.Add(currentBook.BookName);
                }
            }
            else
            {
                classLXXBook currentBook;
                for (idx = 0; idx < globalVars.NoOfLXXBookGroups; idx++)
                {
                    if (globalVars.ChkLXXBooks[idx].Checked) checkedCategories.Add(idx + 1);
                }
                targetListbox = (ListBox)globalVars.getGroupedControl(globalVars.ListBoxCode, 1);
                targetListbox.Items.Clear();
                for (idx = 0; idx < globalVars.NoOfLXXBooks; idx++)
                {
                    globalVars.LxxBookList.TryGetValue(idx, out currentBook);
                    if (!checkedCategories.Contains(currentBook.Category)) targetListbox.Items.Add(currentBook.CommonName);
                }
            }
        }

        public void searchSetup(int tagVal, int controlTab)
        {
            switch (controlTab)
            {
                case 0:
                    switch (tagVal)
                    {
                        case 1:
                            // Add the last selected word to the primary text box
                            ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 0)).Text = hebrewLexicon.removeAccents(globalVars.LastSelectedMTWord);
                            globalVars.PrimaryMTBookId = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 0)).SelectedIndex;
                            globalVars.PrimaryMTChapNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 1)).SelectedItem.ToString();
                            globalVars.PrimaryMTVNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 2)).SelectedItem.ToString();
                            globalVars.PrimaryMTWordSeq = globalVars.SelectedMTWordSequence;
                            globalVars.PrimaryMTWord = globalVars.LastSelectedMTWord;
                            break;
                        case 2:
                            ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 1)).Text = hebrewLexicon.removeAccents(globalVars.LastSelectedMTWord);
                            globalVars.SecondaryMTBookId = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 0)).SelectedIndex;
                            globalVars.SecondaryMTChapNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 1)).SelectedItem.ToString();
                            globalVars.SecondaryMTVNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 2)).SelectedItem.ToString();
                            globalVars.SecondaryMTWordSeq = globalVars.SelectedMTWordSequence;
                            globalVars.SecondaryMTWord = globalVars.LastSelectedMTWord;
                            hideOrShowAdvancedSearch(true, 1);
                            break;
                    }
                    ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 1)).SelectedIndex = 0;
                    ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 5)).SelectedIndex = 1;
                    break;
                case 1:
                    switch (tagVal)
                    {
                        case 1:
                            // Add the last selected word to the primary text box
                            ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 2)).Text = greekProcs.reduceToBareGreek(globalVars.LastSelectedLXXWord, false);
                            globalVars.PrimaryLXXBookId = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 3)).SelectedIndex;
                            globalVars.PrimaryLXXChapNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 4)).SelectedItem.ToString();
                            globalVars.PrimaryLXXVNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 5)).SelectedItem.ToString();
                            globalVars.PrimaryLXXWordSeq = globalVars.SelectedLXXWordSequence;
                            globalVars.PrimaryLXXWord = globalVars.LastSelectedLXXWord;
                            break;
                        case 2:
                            ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 3)).Text = greekProcs.reduceToBareGreek(globalVars.LastSelectedLXXWord, false);
                            globalVars.SecondaryLXXBookId = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 3)).SelectedIndex;
                            globalVars.SecondaryLXXChapNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 4)).SelectedItem.ToString();
                            globalVars.SecondaryLXXVNo = ((ComboBox)globalVars.getGroupedControl(globalVars.ComboBoxesCode, 5)).SelectedItem.ToString();
                            globalVars.SecondaryLXXWordSeq = globalVars.SelectedLXXWordSequence;
                            globalVars.SecondaryLXXWord = globalVars.LastSelectedLXXWord;
                            hideOrShowAdvancedSearch(true, 2);
                            break;
                    }
                    ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 1)).SelectedIndex = 1;
                    ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 6)).SelectedIndex = 2;
                    break;
            }
        }

        private void hideOrShowAdvancedSearch(bool isToShow, int mtOrLxx)
        {
            switch (mtOrLxx)
            {
                case 1:
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 1)).Visible = isToShow;
                    globalVars.UdMTScan.Visible = isToShow;
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 2)).Visible = isToShow;
                    ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 1)).Visible = isToShow;
                    if (isToShow) ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 0)).Text = "Basic Search";
                    else ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 0)).Text = "Advanced Search";
                    break;
                case 2:
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 4)).Visible = isToShow;
                    globalVars.UdLXXScan.Visible = isToShow;
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 5)).Visible = isToShow;
                    ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 3)).Visible = isToShow;
                    if (isToShow) ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 1)).Text = "Basic Search";
                    else ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 1)).Text = "Advanced Search";
                    break;
            }
        }

        public void setSearchType(int mtOrLxx)
        {
            if (mtOrLxx == 1)
            {
                if (((Label)globalVars.getGroupedControl(globalVars.LabelCode, 1)).Visible)
                {
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 1)).Visible = false;
                    globalVars.UdMTScan.Visible = false;
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 2)).Visible = false;
                    ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 1)).Visible = false;
                    ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 0)).Text = "Advanced Search";
                }
                else
                {
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 1)).Visible = true;
                    globalVars.UdMTScan.Visible = true;
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 2)).Visible = true;
                    ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 1)).Visible = true;
                    ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 0)).Text = "Basic Search";
                }
            }
            else
            {
                if (((Label)globalVars.getGroupedControl(globalVars.LabelCode, 4)).Visible)
                {
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 4)).Visible = false;
                    globalVars.UdLXXScan.Visible = false;
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 5)).Visible = false;
                    ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 3)).Visible = false;
                    ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 1)).Text = "Advanced Search";
                }
                else
                {
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 4)).Visible = true;
                    globalVars.UdLXXScan.Visible = true;
                    ((Label)globalVars.getGroupedControl(globalVars.LabelCode, 5)).Visible = true;
                    ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 3)).Visible = true;
                    ((Button)globalVars.getGroupedControl(globalVars.ButtonCode, 1)).Text = "Basic Search";
                }
            }
        }

        public void controlSearch()
        {
            /*======================================================================================================*
             *                                                                                                      *
             *                                           controlSearch                                              *
             *                                           =============                                              *
             *                                                                                                      *
             *  Key variables used in the procedure:                                                                *
             *  -----------------------------------                                                                 *
             *                                                                                                      *
             *  searchType          Indicates whether the search is "simple" (a single word) or "complex" (one word *
             *                      withing n words of a second). The identification is based on whether lblWithin  *
             *                      is visible or not.                                                              *
             *                      Values of searchType are:                                                       *
             *                        simple:   1                                                                   *
             *                        complex:  2                                                                   *
             *  matchType           The type of matching strategy, as determined by the radio button selected.      *
             *                      Values and significances are:                                                   *
             *                        1    matching is based on BDB Refs.                                           *
             *                        2    matching is "moderate" - based on consonents only                        *
             *                        3    matching is "strict" - both consonents and vowels must match             *
             *                                                                                                      *
             *  Processing:                                                                                         *
             *  ==========                                                                                          *
             *                                                                                                      *
             *  The ultimate purpose of this method (together with its subsidiary methods) is to populate a series  *
             *    of classSearchResults instances, all of which are stored (temporariy) in the global list,         *
             *    currentSearchResults.  These can then be interrogated by the separate method that actually        *
             *    displays them.                                                                                    *
             *                                                                                                      *
             *======================================================================================================*/

            /*------------------------------------------------------------------------------------------------------*
             *                                                                                                      *
             *  Constants:                                                                                          *
             *  ---------                                                                                           *
             *                                                                                                      *
             *  zeroWidthSpace      Used to mark the start of a word (making identification of words easier)        *
             *  zeroWidthNonJoiner  Separates the base word from prefixed "words" such as vav and prepositions      *
             *  noBreakSpace        Used in references to avoid breaking across references and other odd changes    *
             *  ideographicSpace    Used in book names that contain spaces (so we can keep book names intact)       *
             *                                                                                                      *
             *------------------------------------------------------------------------------------------------------*/

            int idx, noOfBooks = 0;
            RadioButton btnInclude;
            Button btnClose;
            TabControl functionalTabControl;
            classMTBook currentMTBook;
            classLXXBook currentLXXBook;

            functionalTabControl = (TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 1);
            currentVersion = functionalTabControl.SelectedIndex;
            matchType = 0;
            isWordGiven = false;
            isSWordGiven = false;

            /*----------------------------------------------------------------------------------------------*
             * Provide initial progress information in the tool strip below the search results area.        *
             *----------------------------------------------------------------------------------------------*/
            ((ToolStripStatusLabel)globalVars.getGroupedControl(globalVars.ToolStripLabelCode, 0)).Text = "Search status:";
            ((ToolStripStatusLabel)globalVars.getGroupedControl(globalVars.ToolStripLabelCode, 1)).Text = "Performing your search";
            globalVars.StatSearch.Refresh();

            booksToInclude.Clear();

            /*----------------------------------------------------------------------------------------------*
             * Check whether the search is "simple" or "complex"                                            *
             *   Set searchType accordingly, then invoke lexicon.performSearch as suitable                  *
             *----------------------------------------------------------------------------------------------*/
            switch ( currentVersion )
            {
                case 0: // Masoretic text
                    if (((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 0)).Text.Length == 0)
                    {
                        MessageBox.Show("You have selected a Search with no Primary word", "Search Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                    if (((Label)globalVars.getGroupedControl(globalVars.LabelCode, 1)).Visible)
                    {
                        if (((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 1)).Text.Length == 0)
                        {
                            MessageBox.Show("You have selected an Advanced Search with no Secondary word", "Search Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                        currentSearchType = 2;
                    }
                    else currentSearchType = 1;

                    /*----------------------------------------------------------------------------------------------*
                     * Record the search type: based on BDB matches, strict or moderate.                            *
                     *----------------------------------------------------------------------------------------------*/
                    if (((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 0)).Checked) matchType = 1;
                    if (((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 1)).Checked) matchType = 2;
                    if (((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 2)).Checked) matchType = 3;
                    btnInclude = (RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 5);

                    noOfBooks = globalVars.NoOfMTBooks;
                    for (idx = 0; idx < noOfBooks; idx++)
                    {
                        // Is the current book in the list to be searched?
                        globalVars.MtBookList.TryGetValue(idx, out currentMTBook);
                        if (btnInclude.Checked)
                        {
                            if (((ListBox)globalVars.getGroupedControl(globalVars.ListBoxCode, 0)).Items.Contains(currentMTBook.BookName))
                                booksToInclude.Add(currentMTBook.BookName);
                        }
                        else
                        {
                            if (!((ListBox)globalVars.getGroupedControl(globalVars.ListBoxCode, 0)).Items.Contains(currentMTBook.BookName))
                                booksToInclude.Add(currentMTBook.BookName);
                        }
                    }
                    break;
                case 1:  // LXX
                    if (((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 2)).Text.Length == 0)
                    {
                        MessageBox.Show("You have selected an Search with no Primary word", "Search Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                    if (((Label)globalVars.getGroupedControl(globalVars.LabelCode, 4)).Visible)
                    {
                        if (((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 3)).Text.Length == 0)
                        {
                            MessageBox.Show("You have selected an Advanced Search with no Secondary word", "Search Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            return;
                        }
                        currentSearchType = 2;
                    }
                    else currentSearchType = 1;

                    /*----------------------------------------------------------------------------------------------*
                     * Record the search type: based on root or exact match.                                        *
                     *----------------------------------------------------------------------------------------------*/
                    if (((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 3)).Checked) matchType = 1;
                    if (((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 4)).Checked) matchType = 2;
                    btnInclude = (RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 6);

                    noOfBooks = globalVars.NoOfLXXBooks;
                    for (idx = 0; idx < noOfBooks; idx++)
                    {
                        // Is the current book in the list to be searched?
                        globalVars.LxxBookList.TryGetValue(idx, out currentLXXBook);
                        if (btnInclude.Checked)
                        {
                            if (((ListBox)globalVars.getGroupedControl(globalVars.ListBoxCode, 0)).Items.Contains(currentLXXBook.CommonName))
                                booksToInclude.Add(currentLXXBook.CommonName);
                        }
                        else
                        {
                            if (!((ListBox)globalVars.getGroupedControl(globalVars.ListBoxCode, 0)).Items.Contains(currentLXXBook.CommonName))
                                booksToInclude.Add(currentLXXBook.CommonName);
                        }
                    }
                    break;
            }

            /*----------------------------------------------------------------------------------------------*
             * Perform a search in a background thread.                                                     *
             *----------------------------------------------------------------------------------------------*/
            btnClose = (Button)globalVars.getGroupedControl(globalVars.ButtonCode, 2);
            btnClose.Visible = true;
            searchThread = new Thread(new ThreadStart(threadControl));
            searchThread.IsBackground = true;
            searchThread.Start();
        }

        private void threadControl()
        {
            switch (currentVersion)
            {
                case 0:
                    switch (currentSearchType)
                    {
                        case 1:
                            mtBaseSearch(1, matchType, globalVars.PrimaryMTBookId, globalVars.PrimaryMTChapNo, globalVars.PrimaryMTVNo, globalVars.PrimaryMTWordSeq,
                                -1, "", "", -1,
                                ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 0)).Text, "", 0,
                                ((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 5)).Checked);
                            break;
                        case 2:
                            mtBaseSearch(2, matchType,
                                globalVars.PrimaryMTBookId, globalVars.PrimaryMTChapNo, globalVars.PrimaryMTVNo, globalVars.PrimaryMTWordSeq,
                                globalVars.SecondaryMTBookId, globalVars.SecondaryMTChapNo, globalVars.SecondaryMTVNo, globalVars.SecondaryMTWordSeq,
                                ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 0)).Text, ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 1)).Text,
                                (int)globalVars.UdMTScan.Value, ((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 5)).Checked);
                            break;
                    }
                    break;
                case 1:
                    switch (currentSearchType)
                    {
                        case 1:
                            lxxBaseSearch(1, matchType,
                                globalVars.PrimaryLXXBookId, globalVars.PrimaryLXXChapNo, globalVars.PrimaryLXXVNo, globalVars.PrimaryLXXWordSeq,
                                -1, "", "", -1,
                                ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 2)).Text, "", 0,
                                ((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 6)).Checked);
                            break;
                        case 2:
                            lxxBaseSearch(2, matchType,
                                globalVars.PrimaryLXXBookId, globalVars.PrimaryLXXChapNo, globalVars.PrimaryLXXVNo, globalVars.PrimaryLXXWordSeq,
                                globalVars.SecondaryLXXBookId, globalVars.SecondaryLXXChapNo, globalVars.SecondaryLXXVNo, globalVars.SecondaryLXXWordSeq,
                                ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 2)).Text,
                                ((TextBox)globalVars.getGroupedControl(globalVars.TextboxCode, 3)).Text,
                                (int)globalVars.UdLXXScan.Value, ((RadioButton)globalVars.getGroupedControl(globalVars.RadioButtonCode, 6)).Checked);
                            break;
                    }
                    break;
            }
        }

        /*======================================================================================================*
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *                                                                                                      *
         *                                      MT Search Methods                                               *
         *                                      =================                                               *
         *                                                                                                      *
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
        /*======================================================================================================*/

        private void mtBaseSearch(int searchType, int matchType, int pBook, String pChap, String pVerse, int pSeq, int sBook, String sChap, String sVerse, int sSeq,
                                    String pWord, String sWord, int searchSpan, bool exclude_include)
        {
            /*===============================================================================================================*
             *                                                                                                               *
             *                                                performSearch                                                  *
             *                                                =============                                                  *
             *                                                                                                               *
             *  Purpose:                                                                                                     *
             *  =======                                                                                                      *
             *                                                                                                               *
             *  To handle the search for both a basic search and an advanced (two-word) search.                              *
             *                                                                                                               *
             *  Parameters:                                                                                                  *
             *  ==========                                                                                                   *
             *    searchType   If this = 1, the search is basic; 2, the search is more complex                               *
             *    matchType    Possible values                                                                               *
             *                 and significance are:                                                                         *
             *                  Value                       Significance                                                     *
             *                    1     Matches are based on BDB References                                                  *
             *                    2     Matches are "moderate" - based on consonents only                                    *
             *                    3     Matches are "strict" - match both consonents and vowels                              *
             *       If the primary word has been populated from the main text (by a right click), then:                     *
             *    pBook        The bookId of the primary search source word                                                  *
             *    pChap        The chapter of the primary search source word                                                 *
             *    pVerse       The verse of the primary search source word                                                   *
             *    pSeq         The sequence in the verse of the primary search source word                                   *
             *    pWord        The actual primary word (without accents, with vowels)                                        *
             *       If the secondary word has been populated from the main text (by a right click), then:                   *
             *    sBook        The bookId of the secondary search source word                                                *
             *    sChap        The chapter of the secondary search source word                                               *
             *    sVerse       The verse of the secondary search source word                                                 *
             *    sSeq         The sequence in the verse of the secondary search source word                                 *
             *    sWord        The actual secondary word (without accents, with vowels)                                      *
             *    searchSpan   An int value; the number of words before and after the matched word in which the secondary    *
             *                   word must occur for a full match.                                                           *
             *    exclude_include                                                                                            *
             *                 If = true, we *include* all in the listed book category                                       *
             *                 if = false, we include those *not* in the category                                            *
             *                                                                                                               *
             *  Returned variable:                                                                                           *
             *  =================                                                                                            *
             *    A String variable containing all/any search results                                                        *
             *                                                                                                               *
             *===============================================================================================================*/

            bool isWorthProgressing = false;
            StatusStrip targetToolStrip;

            initialMTMatchProcessing( pBook, pChap, pVerse, pSeq, pWord, sBook, sChap, sVerse, sSeq, sWord);
            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            isWorthProgressing = isWordGiven;
            if ( (currentSearchType == 2) && (!isSWordGiven)) isWorthProgressing = false;
            if (isWorthProgressing)
            {
                // We now have an assured list of Strong references to the word.  Now hunt for all occurrences
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Scanning the OT for uses of " + pWord);
                if (searchType == 1) primaryMTScan(targetToolStrip, pWord, matchType);
                else secondaryMTScan(pWord, sWord, searchSpan);
                isSearchSuccessful = true;
            }
            else isSearchSuccessful = false;
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Search complete");
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, "");
            displayMTResults();
        }

        private void initialMTMatchProcessing(int pBook, String pChap, String pVerse, int pSeq, String pWord, int sBook, String sChap, String sVerse, int sSeq, String sWord)
        {
            int idx, noOfStrongNos = 0;
            StatusStrip targetToolStrip;
            classWordToStrong currentConversion;
            Tuple<bool, SortedSet<int>> verifyResult;

            strongRefs = null;
            SecondStrongRefs = null;
            isSearchSuccessful = false;
            noOfMatchingVerses = 0;
            listOfMTPrimaryResults.Clear();
            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Analysing the given primary word");
            // 1  Let's find all primary matches first
            // 1a If the primary word is not set, then we need to find an example
            if (pBook >= 0)
            {
                // Okay, we have a word.  But does it match?
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, pWord + "found; checking validity");
                verifyResult = mtVerifyWord(pBook, pChap, pVerse, pSeq, pWord, matchType);
                isWordGiven = verifyResult.Item1;
                if (isWordGiven) strongRefs = verifyResult.Item2;
            }
            // No, it didn't match
            if (!isWordGiven)
            {
                // We need to find the given word; it was entered manually
                currentConversion = null;
                if (mtText.ListOfStrongConversions.ContainsKey(pWord)) mtText.ListOfStrongConversions.TryGetValue(pWord, out currentConversion);
                if (currentConversion != null)
                {
                    noOfStrongNos = currentConversion.NoOfStrongRefs;
                    for (idx = 0; idx < noOfStrongNos; idx++)
                    {
                        if (strongRefs == null) strongRefs = new SortedSet<int>();
                        strongRefs.Add(currentConversion.getStrongRefByIndex(idx));
                    }
                    isWordGiven = true;
                }
            }
            // Now we have something
            if (isWordGiven)
            {
                // Step 2: if it is a secondary search, we need to repeat the process
                //         Note: we must strictly partition the responses for primary and secondary words
                if (currentSearchType == 2)
                {
                    targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Analysing the given secondary word");
                    if (sBook >= 0)
                    {
                        // Okay, we have a word.  But does it match?
                        targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, sWord + " found; checking validity");
                        verifyResult = mtVerifyWord(sBook, sChap, sVerse, sSeq, sWord, matchType);
                        isSWordGiven = verifyResult.Item1;
                        if (isSWordGiven) SecondStrongRefs = verifyResult.Item2;
                    }
                    // No, it didn't match
                    if (!isSWordGiven)
                    {
                        // We need to find the given word; it was entered manually
                        currentConversion = null;
                        if (mtText.ListOfStrongConversions.ContainsKey(sWord)) mtText.ListOfStrongConversions.TryGetValue(sWord, out currentConversion);
                        if (currentConversion != null)
                        {
                            noOfStrongNos = currentConversion.NoOfStrongRefs;
                            for (idx = 0; idx < noOfStrongNos; idx++)
                            {
                                if (SecondStrongRefs == null) SecondStrongRefs = new SortedSet<int>();
                                SecondStrongRefs.Add(currentConversion.getStrongRefByIndex(idx));
                            }
                            isSWordGiven = true;
                        }
                    }
                }
            }
        }

        private void primaryMTScan(StatusStrip targetToolStrip, String targetWord, int matchType)
        {
            bool isAMatchFound, isExisting = false;
            int noOfBooks, idx, bdx, cdx, vdx, wdx, noOfChaps, noOfVerses, noOfWords, noOfStrongNos = 0;
            classMTBook currentBook;
            classMTChapter currentChapter;
            classMTVerse currentVerse;
            classMTWord currentWord;
            classMTPrimaryResult primaryResult, prevSearchResult;

            noOfBooks = globalVars.NoOfMTBooks;
            for (bdx = 0; bdx < noOfBooks; bdx++)
            {
                // Is the current book in the list to be searched?
                globalVars.MtBookList.TryGetValue(bdx, out currentBook);
                if (!booksToInclude.Contains(currentBook.BookName)) continue;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, currentBook.BookName);
                noOfChaps = currentBook.NoOfChaptersInBook;
                for (cdx = 0; cdx < noOfChaps; cdx++)
                {
                    currentChapter = currentBook.getChapterBySequence(cdx);
                    noOfVerses = currentChapter.NoOfVersesInChapter;
                    for (vdx = 0; vdx < noOfVerses; vdx++)
                    {
                        currentVerse = currentChapter.getVerseBySequence(vdx);
                        noOfWords = currentVerse.WordCount;
                        for (wdx = 0; wdx < noOfWords; wdx++)
                        {
                            isAMatchFound = false;
                            currentWord = currentVerse.getWord(wdx);
                            noOfStrongNos = currentWord.NoOfStrongRefs;
                            for (idx = 0; idx < noOfStrongNos; idx++)
                            {
                                isAMatchFound = isThereAnMTMatch(currentWord, matchType, strongRefs, targetWord);
                                if (isAMatchFound) break;
                            }
                            if (isAMatchFound)
                            {
                                prevSearchResult = null;
                                isExisting = false;
                                if( noOfMatchingVerses > 0 )
                                {
                                    listOfMTPrimaryResults.TryGetValue(noOfMatchingVerses - 1, out prevSearchResult);
                                    if( prevSearchResult != null)
                                    {
                                        if( ( bdx == prevSearchResult.BookId ) && ( cdx == prevSearchResult.ChapSeq) && ( vdx == prevSearchResult.VerseSeq) )
                                        {
                                            isExisting = true;
                                        }
                                    }
                                }
                                if (isExisting) primaryResult = prevSearchResult;
                                else
                                {
                                    primaryResult = new classMTPrimaryResult();
                                    primaryResult.BookId = bdx;
                                    primaryResult.ChapSeq = cdx;
                                    primaryResult.VerseSeq = vdx;
                                    primaryResult.ChapReference = currentBook.getChapterNoBySequence(cdx);
                                    primaryResult.VerseReference = currentChapter.getVerseNoBySequence(vdx);
                                    primaryResult.ImpactedVerse = currentVerse;
                                }
                                primaryResult.addWordPosition(wdx);
                                if(primaryResult.NoOfMatchingWords == 1) listOfMTPrimaryResults.Add(noOfMatchingVerses++, primaryResult);
                            }
                        }
                    }
                }
            }
        }

        private void secondaryMTScan(String pWord, String sWord, int searchSpan)
        {
            /*==========================================================================================================*
             *                                                                                                          *
             *                                         secondaryMTScan                                                  *
             *                                         ===============                                                  *
             *                                                                                                          *
             *  We are taking a completely different tack for the more complex search (a Primary and Secondary match    *
             *    within a given number of words of each other).                                                        *
             *                                                                                                          *
             *  In its simplest form, a verse may be of the form P ... S or S ... P - i.e. within the verse, there is a *
             *    single instance of each of the target words.                                                          *
             *                                                                                                          *
             *  Somewhat more complex is that this matching pair may occur across verse boundaries.  We have taken the  *
             *    tactical decision that such cross-verse matches will, at worst, span three verses.                    *
             *                                                                                                          *
             *  Somewhat more complex, is a variety of more complex matches - for example:                              *
             *                                                                                                          *
             *                P .. P ... S              or        S  .. S ... P                                         *
             *                P ... S ... P             or        S ... P ... S                                         *
             *                                                                                                          *
             *  In previous versions of the application we used the primary scan to identify P and then revisited each  *
             *    match of P to identify matching occurrences of S.  However, were the verse was of the form            *
             *                                                                                                          *
             *                                 P .... P ... S                                                           *
             *                                                                                                          *
             *  the first occurrence of the primary match sometimes masked the second, closer match and the proximate   *
             *    match was missed.                                                                                     *
             *                                                                                                          *
             *  Matching Tactic                                                                                         *
             *  ===============                                                                                         *
             *                                                                                                          *
             *  1. Load three contguous verses                                                                          *
             *  2. Scan the collection for the first occurrence of either P or S                                        *
             *  3. If found, continue for the next n words in search for S or P (where n = searchSpan)                  *
             *  4. Whether found or not, repeat 2. for the next occurrence                                              *
             *  5. If a match is found, inspect previous matches to see whether an identical match has already been     *
             *     found and, if it has, ignore the current match                                                       *
             *  6. If a previous match is not found, then store the result                                              *
             *  7. Once all words have been checked, remove the first of the three verses, shift the remaining two up   *
             *     one level and then add the next available verse.                                                     *
             *  8. Repeat steps 2 to 7                                                                                  *
             *                                                                                                          *
             *  Note, we do _not_ look for matches across book boundaries but we do across chapter boundaries.          *
             *                                                                                                          *
             *==========================================================================================================*/

            bool isAMatchFound;
            int idx, jdx, bdx, wdx, noOfWords, noOfScanUnits, noOfCurrentMatches = 0, lastChapSeq, lastVerseSeq;
            String bookName;
            StatusStrip targetToolStrip;
            classMTBook currentSBook;
            classMTChapter currentSChapter;
            classMTVerse currentSVerse, scannedSVerse;
            classMTVerse[] verseTriad;
            classMTWord currentSWord;
            classScanUnit currentScanUnit, secondScanUnit;
            classMTSearchMatches currentSearchMatch, pastSearchMatch;
            SortedList<int, classScanUnit> scanSource = new SortedList<int, classScanUnit>();
            SortedList<int, classMTSearchMatches> currentMatches = null;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Scanning for matches of " + pWord + " with " + sWord);
            currentSBook = null;
            allMatches.Clear();
            noOfAllMatches = 0;
            for (bdx = 0; bdx < globalVars.NoOfMTBooks; bdx++)
            {
                globalVars.MtBookList.TryGetValue(bdx, out currentSBook);
                bookName = currentSBook.BookName;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Currently searching " + bookName);
                // Get the first three verses
                verseTriad = new classMTVerse[3];
                currentSChapter = currentSBook.getChapterBySequence(0);
                currentSVerse = currentSChapter.getVerseBySequence(0);
                verseTriad[0] = currentSVerse;
                currentSVerse = currentSVerse.NextVerse;
                verseTriad[1] = currentSVerse;
                currentSVerse = currentSVerse.NextVerse;
                verseTriad[2] = currentSVerse;
                lastChapSeq = currentSBook.NoOfChaptersInBook;
                lastVerseSeq = currentSChapter.NoOfVersesInChapter;
                // Now startScanning
                do
                {
                    // First, put the target words into a structure we can work with
                    noOfScanUnits = 0;
                    scanSource.Clear();
                    for (idx = 0; idx < 3; idx++)
                    {
                        scannedSVerse = verseTriad[idx];
                        noOfWords = scannedSVerse.WordCount;
                        for (wdx = 0; wdx < noOfWords; wdx++)
                        {
                            currentSWord = scannedSVerse.getWord(wdx);
                            currentScanUnit = new classScanUnit();
                            currentScanUnit.ScanWord = currentSWord;
                            currentScanUnit.ChapterRef = scannedSVerse.ChapRef;
                            currentScanUnit.VerseRef = scannedSVerse.VerseRef;
                            currentScanUnit.ChapterSeq = scannedSVerse.ChapSeq;
                            currentScanUnit.VerseSeq = scannedSVerse.VerseSeq;
                            currentScanUnit.WordSeq = wdx;
                            scanSource.Add(noOfScanUnits++, currentScanUnit);
                        }
                    }
                    // Now scan through this set of words
                    noOfCurrentMatches = 0;
                    currentMatches = new SortedList<int, classMTSearchMatches>();
                    for ( idx = 0; idx < noOfScanUnits; idx++)
                    {
                        scanSource.TryGetValue(idx, out currentScanUnit);
                        isAMatchFound = isThereAnMTMatch(currentScanUnit.ScanWord, matchType, strongRefs, pWord);
                        if (isAMatchFound)
                        {
                            // Look for an occurrence of the secondary within searchSpan words
                            for( jdx = 1; jdx <= searchSpan; jdx++)
                            {
                                if (idx + jdx >= noOfScanUnits) break;
                                scanSource.TryGetValue(idx + jdx, out secondScanUnit);
                                isAMatchFound = isThereAnMTMatch(secondScanUnit.ScanWord, matchType, SecondStrongRefs, sWord);
                                if( isAMatchFound)
                                {
                                    currentSearchMatch = new classMTSearchMatches();
                                    currentSearchMatch.PrimaryScanWord = currentScanUnit.ScanWord;
                                    currentSearchMatch.BookId = bdx;
                                    currentSearchMatch.PrimaryChapterRef = currentScanUnit.ChapterRef;
                                    currentSearchMatch.PrimaryVerseRef = currentScanUnit.VerseRef;
                                    currentSearchMatch.PrimaryChapterSeq = currentScanUnit.ChapterSeq;
                                    currentSearchMatch.PrimaryVerseSeq = currentScanUnit.VerseSeq;
                                    currentSearchMatch.PrimaryWordSeq = currentScanUnit.WordSeq;
                                    currentSearchMatch.SecondaryScanWord = secondScanUnit.ScanWord;
                                    currentSearchMatch.SecondaryChapterRef = secondScanUnit.ChapterRef;
                                    currentSearchMatch.SecondaryVerseRef = secondScanUnit.VerseRef;
                                    currentSearchMatch.SecondaryChapterSeq = secondScanUnit.ChapterSeq;
                                    currentSearchMatch.SecondaryVerseSeq = secondScanUnit.VerseSeq;
                                    currentSearchMatch.SecondaryWordSeq = secondScanUnit.WordSeq;
                                    currentMatches.Add(noOfCurrentMatches++, currentSearchMatch);
                                }
                            }
                        }
                        else
                        {
                            // Now look for a secondary match
                            isAMatchFound = isThereAnMTMatch(currentScanUnit.ScanWord, matchType, SecondStrongRefs, sWord);
                            if (isAMatchFound)
                            {
                                // Look for an occurrence of the primary within searchSpan words
                                for (jdx = 1; jdx <= searchSpan; jdx++)
                                {
                                    if (idx + jdx >= noOfScanUnits) break;
                                    scanSource.TryGetValue(idx + jdx, out secondScanUnit);
                                    isAMatchFound = isThereAnMTMatch(secondScanUnit.ScanWord, matchType, strongRefs, pWord);
                                    if (isAMatchFound)
                                    {
                                        currentSearchMatch = new classMTSearchMatches();
                                        currentSearchMatch.PrimaryScanWord = secondScanUnit.ScanWord;
                                        currentSearchMatch.BookId = bdx;
                                        currentSearchMatch.PrimaryChapterRef = secondScanUnit.ChapterRef;
                                        currentSearchMatch.PrimaryVerseRef = secondScanUnit.VerseRef;
                                        currentSearchMatch.PrimaryChapterSeq = secondScanUnit.ChapterSeq;
                                        currentSearchMatch.PrimaryVerseSeq = secondScanUnit.VerseSeq;
                                        currentSearchMatch.PrimaryWordSeq = secondScanUnit.WordSeq;
                                        currentSearchMatch.SecondaryScanWord = currentScanUnit.ScanWord;
                                        currentSearchMatch.SecondaryChapterRef = currentScanUnit.ChapterRef;
                                        currentSearchMatch.SecondaryVerseRef = currentScanUnit.VerseRef;
                                        currentSearchMatch.SecondaryChapterSeq = currentScanUnit.ChapterSeq;
                                        currentSearchMatch.SecondaryVerseSeq = currentScanUnit.VerseSeq;
                                        currentSearchMatch.SecondaryWordSeq = currentScanUnit.WordSeq;
                                        currentMatches.Add(noOfCurrentMatches++, currentSearchMatch);
                                    }
                                }
                            }
                        }
                    }
                    // We now have _potential matches but they may already have been identified
                    for( idx = 0; idx < noOfAllMatches; idx++)
                    {
                        allMatches.TryGetValue(idx, out pastSearchMatch);
                        for( jdx = 0; jdx < noOfCurrentMatches; jdx++)
                        {
                            currentMatches.TryGetValue(jdx, out currentSearchMatch);
                            if ((currentSearchMatch.BookId == pastSearchMatch.BookId) &&
                               (currentSearchMatch.PrimaryChapterSeq == pastSearchMatch.PrimaryChapterSeq) &&
                               (currentSearchMatch.PrimaryVerseSeq == pastSearchMatch.PrimaryVerseSeq) &&
                               (currentSearchMatch.SecondaryChapterSeq == pastSearchMatch.SecondaryChapterSeq) &&
                               (currentSearchMatch.SecondaryVerseSeq == pastSearchMatch.SecondaryVerseSeq)) currentSearchMatch.IsValid = false;
                        }
                    }
                    // Now we've checked everything, add new valid results to the list of matches
                    for( jdx = 0; jdx < noOfCurrentMatches; jdx++)
                    {
                        currentMatches.TryGetValue(jdx, out currentSearchMatch);
                        if (currentSearchMatch.IsValid) allMatches.Add(noOfAllMatches++, currentSearchMatch);
                    }
                    verseTriad[0] = verseTriad[1];
                    verseTriad[1] = verseTriad[2];
                    currentSVerse = currentSVerse.NextVerse;
                    verseTriad[2] = currentSVerse;
                } while (currentSVerse.NextVerse != null);
            }
        }

        private bool isThereAnMTMatch(classMTWord currentWord, int matchType, SortedSet<int> strongRefs, String targetWord)
        {
            bool isFound = false;
            int tempStrongNo, idx, noOfStrongNos;
            String candidateWord;

            switch (matchType)
            {
                case 1:
                    noOfStrongNos = currentWord.NoOfStrongRefs;
                    for (idx = 0; idx < noOfStrongNos; idx++)
                    {
                        tempStrongNo = currentWord.getStrongRefBySeq(idx);
                        if (strongRefs.Contains(tempStrongNo))
                        {
                            isFound = true;
                            break;
                        }
                    }
                    break;
                case 2:
                    candidateWord = currentWord.UnaccentedWord;
                    if (String.Compare(candidateWord, targetWord) == 0) isFound = true;
                    break;
                case 3:
                    candidateWord = currentWord.BareWord;
                    if (String.Compare(candidateWord, removeNonConsonents(targetWord)) == 0) isFound = true;
                    break;
            }
            return isFound;
        }

        public String removeNonConsonents(String sourceWord)
        {
            /*==============================================================================================*
             *                                                                                              *
             *                                       removeNonConsonents                                    *
             *                                       ===================                                    *
             *                                                                                              *
             *  Purpose: to remove all except core Hebrew characters                                        *
             *                                                                                              *
             *  This will remove:                                                                           *
             *           a) vowel pointing                                                                  *
             *           b) sin/shin points                                                                 *
             *           c) dagesh (forte and line)                                                         *
             *                                                                                              *
             *  Parameter:                                                                                  *
             *  =========                                                                                   *
             *                                                                                              *
             *  sourceWord   may be a word, sentence or entire verse, so can includes spaces.               *
             *                                                                                              *
             *==============================================================================================*/

            int idx, wordLength;
            String resultingWord = "";

            wordLength = sourceWord.Length;
            for (idx = 0; idx < wordLength; idx++)
            {
                // Is the character a standard Hebrew consonant?
                if (((int)sourceWord[idx] >= 0x5d0) && ((int)sourceWord[idx] <= 0x5ea))
                {
                    resultingWord += sourceWord.Substring(idx, 1);
                    continue;
                }
                // Is the character a low order ASCII character, including space and non-break space
                if ((sourceWord[idx] >= 0x0020) & (sourceWord[idx] <= 0x00a0))
                {
                    resultingWord += sourceWord.Substring(idx, 1);
                    continue;
                }
                // Is the character a carriage return?
                if (sourceWord[idx] == '\n')
                {
                    resultingWord += "\n";
                    continue;
                }
            }
            return resultingWord;
        }

        private Tuple<bool, SortedSet<int>> mtVerifyWord(int bookNo, String chapRef, String verseRef, int wordSeq, String wordToVerify, int matchType)
        {
            bool isWordGiven = false;
            SortedSet<int> strongRefs = new SortedSet<int>();
            classMTBook currentBook;
            classMTChapter currentChapter;
            classMTVerse currentVerse;
            classMTWord currentWord;

            globalVars.MtBookList.TryGetValue(bookNo, out currentBook);
            currentChapter = currentBook.getChapterByChapterNo(chapRef);
            currentVerse = currentChapter.getVerseByVerseNo(verseRef);
            currentWord = currentVerse.getWord(wordSeq);
            if (matchType < 3)
            {
                if (String.Compare(currentWord.UnaccentedWord, wordToVerify) == 0)
                {
                    isWordGiven = true;
                    strongRefs = getStrongRefs(currentWord);
                }
            }
            else
            {
                // If we _didn't_ match, try it without vowels
                if (String.Compare(currentWord.BareWord, wordToVerify) == 0)
                {
                    isWordGiven = true;
                    strongRefs = getStrongRefs(currentWord);
                }
            }
            return new Tuple<bool, SortedSet<int>>(isWordGiven, strongRefs);
        }

        private SortedSet<int> getStrongRefs(classMTWord currentWord)
        {
            int idx, noOfStrongNos = 0;
            SortedSet<int> tempList = new SortedSet<int>();

            noOfStrongNos = currentWord.NoOfStrongRefs;
            for (idx = 0; idx < noOfStrongNos; idx++)
            {
                tempList.Add(currentWord.getStrongRefBySeq(idx));
            }
            return tempList;
        }

        private void displayMTResults()
        {
            Label confirmationLabel;
            Button stopButton;
            StatusStrip targetToolStrip;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            confirmationLabel = (Label)globalVars.getGroupedControl(globalVars.LabelCode, 1);
            confirmationLabel.Invoke(new performVisibilityCheck(checkLabelVisibility), confirmationLabel);
            if (isSearchSuccessful)
            {
                if (currentSearchType == 1) displayPrimary();
                else displaySecondary();
            }
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Search complete");
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Current task finished");
            stopButton = (Button)globalVars.getGroupedControl(globalVars.ButtonCode, 2);
            stopButton.Invoke(new performHideStopButton(hideStopButton));
        }

        private void displayPrimary()
        {
            const char zeroWidthSpace = '\u200b', zeroWidthNonJoiner = '\u200d', noBreakSpace = '\u00a0', ideographicSpace = '\u3000';

            int idx, noOfMatches, wdx, noOfWords = 0, noOfLines, boxHeight;
            String postfix, theAffix, referenceText;
            FlowLayoutPanel flowResults;
            RichTextBox rtxtReference, rtxtText;
            TabControl searchTab;
            StatusStrip targetToolStrip;
            classMTBook currentBook;
            classMTVerse currentVerse;
            classMTWord currentWord;
            classMTPrimaryResult currentSearchResult;

            Font mainFont, engFont, primaryFont;
            Color engTextColour, hebTextColour, primeMatchColour, bgColour;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            engFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(4, 1), globalVars.getDefinedStyleByIndex(4, 1), globalVars.getTextSize(4, 1));
            mainFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(4, 2), globalVars.getDefinedStyleByIndex(4, 2), globalVars.getTextSize(4, 2));
            primaryFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(4, 3), globalVars.getDefinedStyleByIndex(4, 3), globalVars.getTextSize(4, 3));
            searchTab = (TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 4);
            searchTab.Invoke(new performTabSelection(selectTab), searchTab, 2);
            flowResults = globalVars.FlowResults;
            flowResults.Invoke(new performPanelClear(clearFlowPanel), flowResults);
            bgColour = globalVars.getColourSetting(4, 0);
            engTextColour = globalVars.getColourSetting(4, 1);
            hebTextColour = globalVars.getColourSetting(4, 2);
            primeMatchColour = globalVars.getColourSetting(4, 3);
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Displaying results");
            noOfMatches = noOfMatchingVerses;
            globalVars.MtSearchText = new RichTextBox[2, 2 * noOfMatches];
            globalVars.NoOfMTResultsItems = 2 * noOfMatches;
            noOfLines = 0;
            for (idx = 0; idx < noOfMatches; idx++)
            {
                currentSearchResult = null;
                if (listOfMTPrimaryResults.ContainsKey(idx)) listOfMTPrimaryResults.TryGetValue(idx, out currentSearchResult);
                globalVars.MtBookList.TryGetValue(currentSearchResult.BookId, out currentBook);
                currentVerse = currentSearchResult.ImpactedVerse;
                    rtxtReference = initialSetupOfRText(bgColour, col1Width, RightToLeft.No, noOfLines);
                    flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtReference);
                    rtxtText = initialSetupOfRText(bgColour, flowResults.Width - col1Width - flowSpacer, RightToLeft.Yes, noOfLines);
                    flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtText);
                    globalVars.MtSearchText[0, noOfLines] = rtxtReference;
                    globalVars.MtSearchText[1, noOfLines++] = rtxtText;
                    // Where a book name contains spaces, we don't want this split wierdly because of right-to-left text, so we use "\u3000" as a space
                    referenceText = currentBook.BookName.Replace(' ', ideographicSpace) + noBreakSpace.ToString() + currentSearchResult.ChapReference + "." + currentSearchResult.VerseReference;
                    targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, referenceText);
                    rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 1, engFont);
                    rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 2, engTextColour);
                    rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 3, referenceText + ":  ");
                    noOfWords = currentVerse.WordCount;
                    for (wdx = 0; wdx < noOfWords; wdx++)
                    {
                        if (currentSearchResult.MatchingWordPositions.ContainsValue(wdx))
                        {
                            rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, primaryFont);
                            rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, primeMatchColour);
                        }
                        else
                        {
                            rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                            rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, hebTextColour);
                        }
                        currentWord = currentVerse.getWord(wdx);
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, zeroWidthSpace + currentWord.ActualWord);
                        if (!(currentWord.IsPrefix) && (String.Compare(currentWord.Affix, "־") != 0)) postfix = " ";
                        else postfix = "";
                        if (currentWord.Affix.Length > 0) theAffix = currentWord.Affix;
                        else theAffix = "";
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, hebTextColour);
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, theAffix + postfix);
                    }
                    rtxtText.Invoke(new performRichTextBoxHeightDetermination(getNewRTXHeight), rtxtText, mainFont);
                    boxHeight = noOfRTXLines;
                    rtxtReference.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtReference, boxHeight);
                    rtxtText.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtText, boxHeight);
            }
        }

        private void displaySecondary()
        {
            /*========================================================================================================================*
             *                                                                                                                        *
             *                                                 displaySecondary                                                       *
             *                                                 ================                                                       *
             *                                                                                                                        *
             *  Manage the display of verses satisfying a complex search, consisting of two words within a set number of words of     *
             *    each other.                                                                                                         *
             *                                                                                                                        *
             *  The starting point of this process is a list of class instances, allMatches, which each list a primary and secondary  *
             *    word that satisfy the search criteria.  Note that:                                                                  *
             *                                                                                                                        *
             *    a) the list will be in strict sequence;                                                                             *
             *    b) the determining word, however, may be either a primary or secondary match;                                       *
             *    c) the matching word (either primary or secondary, that comes second) may be within the same verse or the following *
             *         verse or the one after;                                                                                        *
             *    d) additional matches may occur after the first element of the previous match but before the second;                *
             *    e) specifically, we may get:                                                                                        *
             *           match n: primary is chapter 6.4, word 5 while secondary is 6.5, word 2                                       *
             *           match n+1: primary is chapter 6.4, word 7 while secondary is also 6.5, word 2                                *
             *                                                                                                                        *
             *  Processing:                                                                                                           *
             *  ==========                                                                                                            *
             *                                                                                                                        *
             *  In order to convert the indiidual matches into information that can be displayed, we will first convert each match to *
             *    a unique reference value.  To do this, we perform the calculation:                                                  *
             *                                                                                                                        *
             *                        referenceValue = 1 000 000 * bookId + 1000 * chapterSeq + verseSeq                              *
             *                                                                                                                        *
             *    This will than be used as a key for a verse reference.  If the source record has the second match in a different    *
             *    verse to the first, then the stored verse information will also be marked as "contiguous" with the next.            *
             *                                                                                                                        *
             *========================================================================================================================*/

            const char zeroWidthSpace = '\u200b', zeroWidthNonJoiner = '\u200d', noBreakSpace = '\u00a0', ideographicSpace = '\u3000';

            int idx, bdx, primaryChap, primaryVerse, secondaryChap, secondaryVerse, wdx, noOfWords = 0, noOfLines, boxHeight, 
                    primaryReferenceValue, secondaryReferenceValue, index = 0, typeCode;
            String postfix, theAffix, referenceText;
            FlowLayoutPanel flowResults;
            RichTextBox rtxtReference, rtxtText;
            TabControl searchTab;
            StatusStrip targetToolStrip;
            SortedList<int, classMTSearchVerse> versesMatched = new SortedList<int, classMTSearchVerse>();
            classMTBook currentBook;
            classMTChapter currentChapter;
            classMTVerse currentVerse;
            classMTWord currentWord;
            classMTSearchVerse primarySearchVerse, secondarySearchVerse;
            classMTSearchMatches currentMatch;

            Font mainFont, engFont, primaryFont, secondaryFont;
            Color engTextColour, hebTextColour, primeMatchColour, secondMatchColour, bgColour;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            engFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(4, 1), globalVars.getDefinedStyleByIndex(4, 1), globalVars.getTextSize(4, 1));
            mainFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(4, 2), globalVars.getDefinedStyleByIndex(4, 2), globalVars.getTextSize(4, 2));
            primaryFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(4, 3), globalVars.getDefinedStyleByIndex(4, 3), globalVars.getTextSize(4, 3));
            secondaryFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(4, 4), globalVars.getDefinedStyleByIndex(4, 4), globalVars.getTextSize(4, 4));
            searchTab = (TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 4);
            searchTab.Invoke(new performTabSelection(selectTab), searchTab, 2);
            flowResults = globalVars.FlowResults;
            flowResults.Invoke(new performPanelClear(clearFlowPanel), flowResults);
            bgColour = globalVars.getColourSetting(4, 0);
            engTextColour = globalVars.getColourSetting(4, 1);
            hebTextColour = globalVars.getColourSetting(4, 2);
            primeMatchColour = globalVars.getColourSetting(4, 3);
            secondMatchColour = globalVars.getColourSetting(4, 4);
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Displaying results");
            // Step 1: Arrange the list of all matches further
            for (idx = 0; idx < noOfAllMatches; idx++)
            {
                allMatches.TryGetValue(idx, out currentMatch);
                bdx = currentMatch.BookId;
                globalVars.MtBookList.TryGetValue(bdx, out currentBook);
                primaryChap = currentMatch.PrimaryChapterSeq;
                primaryVerse = currentMatch.PrimaryVerseSeq;
                secondaryChap = currentMatch.SecondaryChapterSeq;
                secondaryVerse = currentMatch.SecondaryVerseSeq;
                primaryReferenceValue = bdx * 1000000 + primaryChap * 1000 + primaryVerse;
                secondaryReferenceValue = bdx * 1000000 + secondaryChap * 1000 + secondaryVerse;
                if (versesMatched.ContainsKey(primaryReferenceValue)) versesMatched.TryGetValue(primaryReferenceValue, out primarySearchVerse);
                else
                {
                    primarySearchVerse = new classMTSearchVerse();
                    primarySearchVerse.BookId = bdx;
                    primarySearchVerse.ChapterNumber = primaryChap;
                    primarySearchVerse.VerseNumber = primaryVerse;
                    primarySearchVerse.ChapterReference = currentMatch.PrimaryChapterRef;
                    primarySearchVerse.VerseReference = currentMatch.PrimaryVerseRef;
                    currentChapter = currentBook.getChapterBySequence(primaryChap);
                    primarySearchVerse.ImpactedVerse = currentChapter.getVerseBySequence(primaryVerse);
                    versesMatched.Add(primaryReferenceValue, primarySearchVerse);
                }
                primarySearchVerse.addWordPosition(currentMatch.PrimaryWordSeq, 1);
                if (versesMatched.ContainsKey(secondaryReferenceValue)) versesMatched.TryGetValue(secondaryReferenceValue, out secondarySearchVerse);
                else
                {
                    secondarySearchVerse = new classMTSearchVerse();
                    secondarySearchVerse.BookId = bdx;
                    secondarySearchVerse.ChapterNumber = secondaryChap;
                    secondarySearchVerse.VerseNumber = secondaryVerse;
                    secondarySearchVerse.ChapterReference = currentMatch.SecondaryChapterRef;
                    secondarySearchVerse.VerseReference = currentMatch.SecondaryVerseRef;
                    currentChapter = currentBook.getChapterBySequence(secondaryChap);
                    secondarySearchVerse.ImpactedVerse = currentChapter.getVerseBySequence(secondaryVerse);
                    versesMatched.Add(secondaryReferenceValue, secondarySearchVerse);
                }
                secondarySearchVerse.addWordPosition(currentMatch.SecondaryWordSeq, 2);
                if (primaryReferenceValue > secondaryReferenceValue) secondarySearchVerse.IsFollowed = true;
                else
                {
                    if (secondaryReferenceValue > primaryReferenceValue) primarySearchVerse.IsFollowed = true;
                }
            }
            // We now have information on all relevant matches
            noOfLines = 0;
            foreach ( KeyValuePair<int, classMTSearchVerse> matchPair in versesMatched)
            {
                noOfLines++;
                primarySearchVerse = matchPair.Value;
                if (!primarySearchVerse.IsFollowed) noOfLines++;
            }
            globalVars.MtSearchText = new RichTextBox[2, noOfLines];
            globalVars.NoOfMTResultsItems = noOfLines;
            noOfLines = 0;
            foreach (KeyValuePair<int, classMTSearchVerse> matchPair in versesMatched)
            {
                rtxtReference = initialSetupOfRText(bgColour, col1Width, RightToLeft.No, noOfLines);
                flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtReference);
                rtxtText = initialSetupOfRText(bgColour, flowResults.Width - col1Width - flowSpacer, RightToLeft.Yes, noOfLines);
                flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtText);
                globalVars.MtSearchText[0, noOfLines] = rtxtReference;
                globalVars.MtSearchText[1, noOfLines++] = rtxtText;
                primarySearchVerse = matchPair.Value;
                currentVerse = primarySearchVerse.ImpactedVerse;
                globalVars.MtBookList.TryGetValue(primarySearchVerse.BookId, out currentBook);
                referenceText = currentBook.BookName.Replace(' ', ideographicSpace) + noBreakSpace.ToString() + 
                                primarySearchVerse.ChapterReference + "." + primarySearchVerse.VerseReference;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, referenceText);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 1, engFont);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 2, engTextColour);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 3, referenceText + ":  ");
                noOfWords = currentVerse.WordCount;
                for (wdx = 0; wdx < noOfWords; wdx++)
                {
                    if (primarySearchVerse.MatchingWordPositions.ContainsValue(wdx))
                    {
                        typeCode = 0;
                        foreach( KeyValuePair<int, int> positionPair in primarySearchVerse.MatchingWordPositions)
                        {
                            if( positionPair.Value == wdx)
                            {
                                index = positionPair.Key;
                                break;
                            }
                        }
                        primarySearchVerse.MatchingWordType.TryGetValue(index, out typeCode);
                        switch( typeCode )
                        {
                            case 0:
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, hebTextColour);
                                break;
                            case 1:
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, primaryFont);
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, primeMatchColour);
                                break;
                            case 2:
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, secondaryFont);
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, secondMatchColour);
                                break;
                        }
                    }
                    else
                    {
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, hebTextColour);
                    }
                    currentWord = currentVerse.getWord(wdx);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, zeroWidthSpace + currentWord.ActualWord);
                    if (!((currentWord.IsPrefix) || (String.Compare(currentWord.Affix, "־") == 0))) postfix = " ";
                    else postfix = "";
                    if (currentWord.Affix.Length > 0) theAffix = zeroWidthNonJoiner + currentWord.Affix;
                    else theAffix = "";
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, hebTextColour);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, theAffix + postfix);
                }
                rtxtText.Invoke(new performRichTextBoxHeightDetermination(getNewRTXHeight), rtxtText, mainFont);
                boxHeight = noOfRTXLines;
                rtxtReference.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtReference, boxHeight);
                rtxtText.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtText, boxHeight);
                if (!primarySearchVerse.IsFollowed)
                {
                    rtxtText = initialSetupOfRText(Color.Black, flowResults.Width - flowSpacer, RightToLeft.No, noOfLines);
                    rtxtText.Height = 5;
                    rtxtText.Visible = true;
                    rtxtText.Text = "";
                    flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtText);
                    globalVars.MtSearchText[0, noOfLines++] = rtxtText;
                }
            }
        }

        /*======================================================================================================*
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *                                                                                                      *
         *                                      LXX Search Methods                                              *
         *                                      ==================                                              *
         *                                                                                                      *
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
        /*======================================================================================================*/

            private void lxxBaseSearch(int searchType, int matchType, int pBook, String pChap, String pVerse, int pSeq, int sBook, String sChap, String sVerse, int sSeq,
                                    String pWord, String sWord, int searchSpan, bool exclude_include)
        {
            /*===============================================================================================================*
             *                                                                                                               *
             *                                               lxxBaseSearch                                                   *
             *                                               =============                                                   *
             *                                                                                                               *
             *  Purpose:                                                                                                     *
             *  =======                                                                                                      *
             *                                                                                                               *
             *  To handle the search for both a basic search and an advanced (two-word) search.                              *
             *                                                                                                               *
             *  Parameters:                                                                                                  *
             *  ==========                                                                                                   *
             *    searchType   If this = 1, the search is basic; 2, the search is more complex                               *
             *    matchType    Possible values                                                                               *
             *                 and significance are:                                                                         *
             *                  Value                       Significance                                                     *
             *                    1     Matches are based on roots (as provided on source data)                              *
             *                    2     Matches are exact matches of the word (without accents)                              *
             *       If the primary word has been populated from the main text (by a right click), then:                     *
             *    pBook        The bookId of the primary search source word                                                  *
             *    pChap        The chapter of the primary search source word                                                 *
             *    pVerse       The verse of the primary search source word                                                   *
             *    pSeq         The sequence in the verse of the primary search source word                                   *
             *    pWord        The actual primary word (without accents, with vowels)                                        *
             *       If the secondary word has been populated from the main text (by a right click), then:                   *
             *    sBook        The bookId of the secondary search source word                                                *
             *    sChap        The chapter of the secondary search source word                                               *
             *    sVerse       The verse of the secondary search source word                                                 *
             *    sSeq         The sequence in the verse of the secondary search source word                                 *
             *    sWord        The actual secondary word (without accents, with vowels)                                      *
             *    searchSpan   An int value; the number of words before and after the matched word in which the secondary    *
             *                   word must occur for a full match.                                                           *
             *    exclude_include                                                                                            *
             *                 If = true, we *include* all in the listed book category                                       *
             *                 if = false, we include those *not* in the category                                            *
             *                                                                                                               *
             *  Returned variable:                                                                                           *
             *  =================                                                                                            *
             *    A String variable containing all/any search results                                                        *
             *                                                                                                               *
             *===============================================================================================================*/

            bool isWorthProgressing = false;
            String primaryString, secondaryString = "";
            StatusStrip targetToolStrip;
            TabControl topRightTabControl;
            Tuple<String, String> confirmWords;

            topRightTabControl = (TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 4);
            topRightTabControl.Invoke(new performTabControlItemSelection(selectTabControlItem), topRightTabControl, 2);
            confirmWords = initialLXXMatchProcessing(pBook, pChap, pVerse, pSeq, pWord, sBook, sChap, sVerse, sSeq, sWord);
            primaryString = confirmWords.Item1;
            secondaryString = confirmWords.Item2;
            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            isWorthProgressing = isWordGiven;
            if ((currentSearchType == 2) && (!isSWordGiven)) isWorthProgressing = false;
            if (isWorthProgressing)
            {
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, "");
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Scanning for uses of " + pWord);
                if (currentSearchType == 1) primaryLXXScan(primaryString, matchType);
                else secondaryLXXScan(primaryString, secondaryString, searchSpan);
                isSearchSuccessful = true;
            }
            else isSearchSuccessful = false;
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Search complete");
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, "");
            displayLXXResults();
        }

        private Tuple<String, String> initialLXXMatchProcessing(int pBook, String pChap, String pVerse, int pSeq, String pWord, 
                                                                int sBook, String sChap, String sVerse, int sSeq, String sWord)
        {
            String primaryString, secondaryString = "";
            StatusStrip targetToolStrip;
            Tuple<String, String, String, String> returnedWordData;
            Tuple<bool, String> verifyResult;

            listOfLXXPrimaryResults.Clear();
            noOfMatchingLXXVerses = 0;
            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Analysing the given primary word");
            // 1  Let's find all primary matches first
            // 1a If the primary word is not set, then we need to find an example
            returnedWordData = greekProcs.removeNonGkChars(pWord);
            primaryString = returnedWordData.Item4;
            primaryString = greekProcs.reduceToBareGreek(primaryString, true);
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, pWord + "found; checking validity");
            verifyResult = lxxVerifyWord(pBook, pChap, pVerse, pSeq, primaryString, matchType);
            isWordGiven = verifyResult.Item1;
            if (!isWordGiven)
            {
                isSearchSuccessful = false;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Search complete");
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, "");
            }
            primaryString = verifyResult.Item2;
            // Now we have something
            if (isWordGiven)
            {
                // Step 2: if it is a secondary search, we need to repeat the process
                //         Note: we must strictly partition the responses for primary and secondary words
                if (currentSearchType == 2)
                {
                    targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Analysing the given secondary word");
                    returnedWordData = greekProcs.removeNonGkChars(sWord);
                    secondaryString = returnedWordData.Item4;
                    secondaryString = greekProcs.reduceToBareGreek(secondaryString, true);
                    targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, sWord + " found; checking validity");
                    verifyResult = lxxVerifyWord(sBook, sChap, sVerse, sSeq, secondaryString, matchType);
                    isSWordGiven = verifyResult.Item1;
                    if (!isSWordGiven)
                    {
                        isSearchSuccessful = false;
                        targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Search complete");
                        targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, "");
                    }
                    secondaryString = verifyResult.Item2;
                }
                return new Tuple<string, string>(primaryString, secondaryString);
            }
            return new Tuple<string, string>("", "");
        }

        private void primaryLXXScan(String targetWord, int matchType)
        {
            bool isAMatchFound, isExisting = false;
            int noOfBooks, bdx, cdx, vdx, wdx, noOfChaps, noOfVerses, noOfWords;
            String currentRoot, wordCleaned;
            StatusStrip targetToolStrip;
            classLXXBook currentBook;
            classLXXChapter currentChapter;
            classLXXVerse currentVerse;
            classLXXWord currentWord;
            classLXXPrimaryResult primaryResult, prevSearchResult;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            noOfBooks = globalVars.NoOfLXXBooks;
            for (bdx = 0; bdx < noOfBooks; bdx++)
            {
                // Is the current book in the list to be searched?
                globalVars.LxxBookList.TryGetValue(bdx, out currentBook);
                if (!booksToInclude.Contains(currentBook.CommonName)) continue;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 2, currentBook.CommonName);
                noOfChaps = currentBook.NoOfChaptersInBook;
                for (cdx = 0; cdx < noOfChaps; cdx++)
                {
                    currentChapter = currentBook.getChapterBySequence(cdx);
                    noOfVerses = currentChapter.NoOfVersesInChapter;
                    for (vdx = 0; vdx < noOfVerses; vdx++)
                    {
                        currentVerse = currentChapter.getVerseBySequence(vdx);
                        noOfWords = currentVerse.WordCount;
                        for (wdx = 0; wdx < noOfWords; wdx++)
                        {
                            isAMatchFound = false;
                            currentWord = currentVerse.getWord(wdx);
                            currentRoot = currentWord.RootWord;
                            wordCleaned = currentWord.AccentlessTextWord;
                            if (matchType == 1) isAMatchFound = (String.Compare(targetWord, currentRoot) == 0);
                            else isAMatchFound = (String.Compare(targetWord, wordCleaned) == 0);
                            if (isAMatchFound)
                            {
                                prevSearchResult = null;
                                isExisting = false;
                                if (noOfMatchingLXXVerses > 0)
                                {
                                    listOfLXXPrimaryResults.TryGetValue(noOfMatchingLXXVerses - 1, out prevSearchResult);
                                    if (prevSearchResult != null)
                                    {
                                        if ((bdx == prevSearchResult.BookId) && (cdx == prevSearchResult.ChapSeq) && (vdx == prevSearchResult.VerseSeq))
                                        {
                                            isExisting = true;
                                        }
                                    }
                                }
                                if (isExisting) primaryResult = prevSearchResult;
                                else
                                {
                                    primaryResult = new classLXXPrimaryResult();
                                    primaryResult.BookId = bdx;
                                    primaryResult.ChapSeq = cdx;
                                    primaryResult.VerseSeq = vdx;
                                    primaryResult.ChapReference = currentBook.getChapterNoBySequence(cdx);
                                    primaryResult.VerseReference = currentChapter.getVerseNoBySequence(vdx);
                                    primaryResult.ImpactedVerse = currentVerse;
                                }
                                primaryResult.addWordPosition(wdx);
                                if (primaryResult.NoOfMatchingWords == 1) listOfLXXPrimaryResults.Add(noOfMatchingLXXVerses++, primaryResult);
                            }
                        }
                    }
                }
            }
        }

        private void secondaryLXXScan(String pWord, String sWord, int searchSpan)
        {
            /*==========================================================================================================*
             *                                                                                                          *
             *                                         secondaryMTScan                                                  *
             *                                         ===============                                                  *
             *                                                                                                          *
             *  See the method, secondaryMTScan, for details of this method.                                            *
             *                                                                                                          *
             *  Matching Tactic                                                                                         *
             *  ===============                                                                                         *
             *                                                                                                          *
             *  1. Load three contguous verses                                                                          *
             *  2. Scan the collection for the first occurrence of either P or S                                        *
             *  3. If found, continue for the next n words in search for S or P (where n = searchSpan)                  *
             *  4. Whether found or not, repeat 2. for the next occurrence                                              *
             *  5. If a match is found, inspect previous matches to see whether an identical match has already been     *
             *     found and, if it has, ignore the current match                                                       *
             *  6. If a previous match is not found, then store the result                                              *
             *  7. Once all words have been checked, remove the first of the three verses, shift the remaining two up   *
             *     one level and then add the next available verse.                                                     *
             *  8. Repeat steps 2 to 7                                                                                  *
             *                                                                                                          *
             *  Note, we do _not_ look for matches across book boundaries but we do across chapter boundaries.          *
             *                                                                                                          *
             *==========================================================================================================*/

            bool isAMatchFound;
            int idx, jdx, bdx, cdx, vdx, wdx, noOfWords, noOfScanUnits, noOfCurrentMatches = 0, lastChapSeq, lastVerseSeq;
            String bookName;
            Tuple<classLXXVerse, int, int> newVerseInfo;
            StatusStrip targetToolStrip;
            classLXXBook currentSBook;
            classLXXChapter currentSChapter;
            classLXXVerse currentSVerse, scannedSVerse;
            classLXXWord currentSWord;
            classLXXVerse[] verseTriad;
            classScanLXXUnit currentScanUnit, secondScanUnit;
            classLXXSearchMatches currentSearchMatch, pastSearchMatch;
            SortedList<int, classScanLXXUnit> scanSource = new SortedList<int, classScanLXXUnit>();
            SortedList<int, classLXXSearchMatches> currentMatches = new SortedList<int, classLXXSearchMatches>();

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Scanning for matches of " + pWord + " with " + sWord);
            currentSBook = null;
            allLXXMatches.Clear();
            noOfAllMatches = 0;
            currentMatches.Clear();
            noOfCurrentMatches = 0;
            for (bdx = 0; bdx < globalVars.NoOfLXXBooks; bdx++)
            {
                // Loop through each book, starting the book afresh
                globalVars.LxxBookList.TryGetValue(bdx, out currentSBook);
                bookName = currentSBook.CommonName;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Currently searching " + bookName);
                // Get the first three verses
                cdx = 0;
                vdx = 0;
                verseTriad = new classLXXVerse[3];
                currentSChapter = currentSBook.getChapterBySequence(0);
                currentSVerse = currentSChapter.getVerseBySequence(0);
                verseTriad[0] = currentSVerse;
                newVerseInfo = getNextVerse(bdx, 0, 0);
                currentSVerse = newVerseInfo.Item1;
                cdx = newVerseInfo.Item2;
                vdx = newVerseInfo.Item2;
                if (currentSVerse != null)
                {
                    verseTriad[1] = currentSVerse;
                    newVerseInfo = getNextVerse(bdx, cdx, vdx);
                    currentSVerse = newVerseInfo.Item1;
                    cdx = newVerseInfo.Item2;
                    vdx = newVerseInfo.Item2;
                    currentSVerse = currentSVerse.NextVerse;
                    if (currentSVerse != null)
                    {
                        verseTriad[2] = currentSVerse;
                    }
                    else
                    {
                        verseTriad[2] = null;
                    }
                }
                else
                {
                    verseTriad[1] = null;
                    verseTriad[2] = null;
                }
                //                lastChapSeq = currentSBook.NoOfChaptersInBook;
                //                lastVerseSeq = currentSChapter.NoOfVersesInChapter;
                // Now startScanning
                do
                {
                    // First, put the target words into a structure we can work with
                    noOfScanUnits = 0;
                    scanSource.Clear();
                    for (idx = 0; idx < 3; idx++)
                    {
                        scannedSVerse = verseTriad[idx];
                        if (scannedSVerse == null) continue;
                        noOfWords = scannedSVerse.WordCount;
                        for (wdx = 0; wdx < noOfWords; wdx++)
                        {
                            currentSWord = scannedSVerse.getWord(wdx);
                            currentScanUnit = new classScanLXXUnit();
                            currentScanUnit.ScanWord = currentSWord;
                            currentScanUnit.ChapterRef = scannedSVerse.ChapRef;
                            currentScanUnit.VerseRef = scannedSVerse.VerseRef;
                            currentScanUnit.ChapterSeq = scannedSVerse.ChapSeq;
                            currentScanUnit.VerseSeq = scannedSVerse.VerseSeq;
                            currentScanUnit.WordSeq = wdx;
                            scanSource.Add(noOfScanUnits++, currentScanUnit);
                        }
                    }
                    // Now scan through this set of words
                    for (idx = 0; idx < noOfScanUnits; idx++)
                    {
                        scanSource.TryGetValue(idx, out currentScanUnit);
                        isAMatchFound = isThereAnLXXMatch(currentScanUnit.ScanWord, currentScanUnit.WordSeq, matchType, pWord);
                        if (isAMatchFound)
                        {
                            // Look for an occurrence of the secondary within searchSpan words
                            for (jdx = 1; jdx <= searchSpan; jdx++)
                            {
                                if (idx + jdx >= noOfScanUnits) break;
                                scanSource.TryGetValue(idx + jdx, out secondScanUnit);
                                isAMatchFound = isThereAnLXXMatch(secondScanUnit.ScanWord, secondScanUnit.WordSeq, matchType, sWord);
                                if (isAMatchFound)
                                {
                                    currentSearchMatch = new classLXXSearchMatches();
                                    currentSearchMatch.PrimaryScanWord = currentScanUnit.ScanWord;
                                    currentSearchMatch.BookId = bdx;
                                    currentSearchMatch.PrimaryChapterRef = currentScanUnit.ChapterRef;
                                    currentSearchMatch.PrimaryVerseRef = currentScanUnit.VerseRef;
                                    currentSearchMatch.PrimaryChapterSeq = currentScanUnit.ChapterSeq;
                                    currentSearchMatch.PrimaryVerseSeq = currentScanUnit.VerseSeq;
                                    currentSearchMatch.PrimaryWordSeq = currentScanUnit.WordSeq;
                                    currentSearchMatch.SecondaryScanWord = secondScanUnit.ScanWord;
                                    currentSearchMatch.SecondaryChapterRef = secondScanUnit.ChapterRef;
                                    currentSearchMatch.SecondaryVerseRef = secondScanUnit.VerseRef;
                                    currentSearchMatch.SecondaryChapterSeq = secondScanUnit.ChapterSeq;
                                    currentSearchMatch.SecondaryVerseSeq = secondScanUnit.VerseSeq;
                                    currentSearchMatch.SecondaryWordSeq = secondScanUnit.WordSeq;
                                    currentMatches.Add(noOfCurrentMatches++, currentSearchMatch);
                                }
                            }
                        }
                        else
                        {
                            // Now look for a secondary match
                            isAMatchFound = isThereAnLXXMatch(currentScanUnit.ScanWord, currentScanUnit.WordSeq, matchType, sWord);
                            if (isAMatchFound)
                            {
                                // Look for an occurrence of the primary within searchSpan words
                                for (jdx = 1; jdx <= searchSpan; jdx++)
                                {
                                    if (idx + jdx >= noOfScanUnits) break;
                                    scanSource.TryGetValue(idx + jdx, out secondScanUnit);
                                    isAMatchFound = isThereAnLXXMatch(secondScanUnit.ScanWord, secondScanUnit.WordSeq, matchType, pWord);
                                    if (isAMatchFound)
                                    {
                                        currentSearchMatch = new classLXXSearchMatches();
                                        currentSearchMatch.PrimaryScanWord = secondScanUnit.ScanWord;
                                        currentSearchMatch.BookId = bdx;
                                        currentSearchMatch.PrimaryChapterRef = secondScanUnit.ChapterRef;
                                        currentSearchMatch.PrimaryVerseRef = secondScanUnit.VerseRef;
                                        currentSearchMatch.PrimaryChapterSeq = secondScanUnit.ChapterSeq;
                                        currentSearchMatch.PrimaryVerseSeq = secondScanUnit.VerseSeq;
                                        currentSearchMatch.PrimaryWordSeq = secondScanUnit.WordSeq;
                                        currentSearchMatch.SecondaryScanWord = currentScanUnit.ScanWord;
                                        currentSearchMatch.SecondaryChapterRef = currentScanUnit.ChapterRef;
                                        currentSearchMatch.SecondaryVerseRef = currentScanUnit.VerseRef;
                                        currentSearchMatch.SecondaryChapterSeq = currentScanUnit.ChapterSeq;
                                        currentSearchMatch.SecondaryVerseSeq = currentScanUnit.VerseSeq;
                                        currentSearchMatch.SecondaryWordSeq = currentScanUnit.WordSeq;
                                        currentMatches.Add(noOfCurrentMatches++, currentSearchMatch);
                                    }
                                }
                            }
                        }  // End of match assessment
                    }  // We have looked through the entire "scan unit"
                    // We now have _potential matches but they may already have been identified
                    for (idx = 0; idx < noOfAllMatches; idx++)
                    {
                        allLXXMatches.TryGetValue(idx, out pastSearchMatch);
                        for (jdx = 0; jdx < noOfCurrentMatches; jdx++)
                        {
                            currentMatches.TryGetValue(jdx, out currentSearchMatch);
                            if ((currentSearchMatch.BookId == pastSearchMatch.BookId) &&
                               (currentSearchMatch.PrimaryChapterSeq == pastSearchMatch.PrimaryChapterSeq) &&
                               (currentSearchMatch.PrimaryVerseSeq == pastSearchMatch.PrimaryVerseSeq) &&
                               (currentSearchMatch.SecondaryChapterSeq == pastSearchMatch.SecondaryChapterSeq) &&
                               (currentSearchMatch.SecondaryVerseSeq == pastSearchMatch.SecondaryVerseSeq)) currentSearchMatch.IsValid = false;
                        }
                    }
                    // Now we've checked everything, add new valid results to the list of matches
                    for (jdx = 0; jdx < noOfCurrentMatches; jdx++)
                    {
                        currentMatches.TryGetValue(jdx, out currentSearchMatch);
                        if (currentSearchMatch.IsValid)
                        {
                            allLXXMatches.Add(noOfAllMatches++, currentSearchMatch);
                        }
                    }
                    verseTriad[0] = verseTriad[1];
                    verseTriad[1] = verseTriad[2];
                    newVerseInfo = getNextVerse(bdx, cdx, vdx);
                    currentSVerse = newVerseInfo.Item1;
                    if (currentSVerse != null)
                    {
                        verseTriad[2] = currentSVerse;
                        cdx = newVerseInfo.Item2;
                        vdx = newVerseInfo.Item3;
                    }
                } while (currentSVerse != null);
            }  // End of looping through book
        }

        private Tuple<classLXXVerse, int, int> getNextVerse( int bookId, int chapSeq, int verseSeq)
        {
            /*======================================================================================================*
             *                                                                                                      *
             *                                          getNextVerse                                                *
             *                                          ============                                                *
             *                                                                                                      *
             *  Get the next verse.  Report back if we have exhausted the verses in the book.  (We need this        *
             *    approach because the "next verse" stored in each verse does _not_ tell us easily when we are at a *
             *    book boundary.                                                                                    *
             *                                                                                                      *
             *  Returned Tuple:                                                                                     *
             *  ==============                                                                                      *
             *                                                                                                      *
             *  item 1:  The new verse instance (if we are at the end of the book, this = null)                     *
             *  item 2:  The new chapter sequence (-1 if an error or end of book)                                   *
             *  item 3:  The new verse sequence (or -1, as above)                                                   *
             *                                                                                                      *
             *======================================================================================================*/

            int noOfVersesInChapter = -1, newVerseSeq, noOfChaptersInBook = -1, newChapSeq = 0;
            classLXXBook currentBook;
            classLXXChapter currentChapter;
            classLXXVerse currentVerse;

            globalVars.LxxBookList.TryGetValue(bookId, out currentBook);
            currentChapter = currentBook.getChapterBySequence(chapSeq);
            noOfVersesInChapter = currentChapter.NoOfVersesInChapter;
            if (noOfVersesInChapter == -1) return new Tuple<classLXXVerse, int, int>(null, -1, -1);
            newVerseSeq = verseSeq + 1;
            newChapSeq = chapSeq;
            if( newVerseSeq >= noOfVersesInChapter)
            {
                newChapSeq++;
                noOfChaptersInBook = currentBook.NoOfChaptersInBook;
                if (newChapSeq >= noOfChaptersInBook) return new Tuple<classLXXVerse, int, int>(null, -1, -1);
                currentChapter = currentBook.getChapterBySequence(newChapSeq);
                newVerseSeq = 0;
            }
            currentVerse = currentChapter.getVerseBySequence(newVerseSeq);
            return new Tuple<classLXXVerse, int, int>(currentVerse, newChapSeq, newVerseSeq);
        }

        private bool isThereAnLXXMatch(classLXXWord currentWord, int wordSeq, int matchType, String targetWord)
        {
            bool isFound = false;
            String candidateWord;

            switch (matchType)
            {
                case 1:
                    candidateWord = currentWord.RootWord;
                    if (String.Compare(targetWord, candidateWord) == 0) isFound = true;
                    break;
                case 2:
                    candidateWord = currentWord.AccentlessTextWord;
                    if (String.Compare(candidateWord, targetWord) == 0) isFound = true;
                    break;
            }
            return isFound;
        }

        private Tuple<bool, String> lxxVerifyWord(int bookNo, String chapRef, String verseRef, int wordSeq, String wordToVerify, int matchType)
        {
            /*======================================================================================================*
             *                                                                                                      *
             *                                         lxxVerifyWord                                                *
             *                                         =============                                                *
             *                                                                                                      *
             *  Purpose:                                                                                            *
             *  =======                                                                                             *
             *                                                                                                      *
             *    (a) to find the root form of the wordToVerify                                                     *
             *    (b) if the word has been entered directly, find the root by matching the word as provided with an *
             *          exact match from the source data.  (Of course, this method is not infallible).              *
             *                                                                                                      *
             *======================================================================================================*/
            int bdx, cdx, vdx, wdx, noOfBooks, noOfChapters, noOfVerses, noOfWords;
            classLXXBook currentBook;
            classLXXChapter currentChapter;
            classLXXVerse currentVerse;
            classLXXWord currentWord;

            if (matchType == 2)
            {
                // We are using exact match comparison.  We have to assume that the words provided are correct,
                //   so there's nothing else to do.
                return new Tuple<bool, string>(true, wordToVerify);
            }
            else
            {
                if (bookNo >= 0)
                {
                    globalVars.LxxBookList.TryGetValue(bookNo, out currentBook);
                    currentChapter = currentBook.getChapterByChapterNo(chapRef);
                    currentVerse = currentChapter.getVerseByVerseNo(verseRef);
                    currentWord = currentVerse.getWord(wordSeq);
                    return new Tuple<bool, string>(true, currentWord.RootWord);
                }
                else
                {
                    noOfBooks = globalVars.NoOfLXXBooks;
                    for (bdx = 0; bdx < noOfBooks; bdx++)
                    {
                        globalVars.LxxBookList.TryGetValue(bdx, out currentBook);
                        noOfChapters = currentBook.NoOfChaptersInBook;
                        for (cdx = 0; cdx < noOfChapters; cdx++)
                        {
                            currentChapter = currentBook.getChapterBySequence(cdx);
                            noOfVerses = currentChapter.NoOfVersesInChapter;
                            for (vdx = 0; vdx < noOfVerses; vdx++)
                            {
                                currentVerse = currentChapter.getVerseBySequence(vdx);
                                noOfWords = currentVerse.WordCount;
                                for (wdx = 0; wdx < noOfWords; wdx++)
                                {
                                    currentWord = currentVerse.getWord(wdx);
                                    if (String.Compare(wordToVerify, currentWord.AccentlessTextWord) == 0)
                                    {
                                        return new Tuple<bool, string>(true, currentWord.RootWord);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return new Tuple<bool, string>(false, "");
        }

        private void displayLXXResults()
        {
            Label confirmationLabel;
            Button stopButton;
            StatusStrip targetToolStrip;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            confirmationLabel = (Label)globalVars.getGroupedControl(globalVars.LabelCode, 4);
            confirmationLabel.Invoke(new performVisibilityCheck(checkLabelVisibility), confirmationLabel);
            if (isSearchSuccessful)
            {
                if (currentSearchType == 1) displayLXXPrimary();
                else displayLXXSecondary();
            }
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Search complete");
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, "Current task finished");
            stopButton = (Button)globalVars.getGroupedControl(globalVars.ButtonCode, 2);
            stopButton.Invoke(new performHideStopButton(hideStopButton));
        }

        private void displayLXXPrimary()
        {
            const char zeroWidthSpace = '\u200b', zeroWidthNonJoiner = '\u200d', noBreakSpace = '\u00a0', ideographicSpace = '\u3000';

            int idx, noOfMatches, wdx, noOfWords = 0, noOfLines, boxHeight;
            String referenceText;
            FlowLayoutPanel flowResults;
            RichTextBox rtxtReference, rtxtText;
            TabControl searchTab;
            StatusStrip targetToolStrip;
            classLXXBook currentBook;
            classLXXVerse currentVerse;
            classLXXWord currentWord;
            classLXXPrimaryResult currentSearchResult;

            Font engFont, mainFont, primaryFont;
            Color engTextColour, gkTextColour, primeMatchColour, bgColour;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            engFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(5, 1), globalVars.getDefinedStyleByIndex(5, 1), globalVars.getTextSize(5, 1));
            mainFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(5, 2), globalVars.getDefinedStyleByIndex(5, 1), globalVars.getTextSize(5, 1));
            primaryFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(5, 3), globalVars.getDefinedStyleByIndex(5, 3), globalVars.getTextSize(5, 3));
            searchTab = (TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 4);
            searchTab.Invoke(new performTabSelection(selectTab), searchTab, 2);
            flowResults = globalVars.FlowResults;
            flowResults.Invoke(new performPanelClear(clearFlowPanel), flowResults);
            bgColour = globalVars.getColourSetting(5, 0);
            engTextColour = globalVars.getColourSetting(5, 1);
            gkTextColour = globalVars.getColourSetting(5, 2);
            primeMatchColour = globalVars.getColourSetting(5, 3);
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Displaying results");
            noOfMatches = noOfMatchingLXXVerses;
            globalVars.LxxSearchText = new RichTextBox[2, 2 * noOfMatches];
            globalVars.NoOfLXXResultsItems = 2 * noOfMatches;
            noOfLines = 0;
            for (idx = 0; idx < noOfMatches; idx++)
            {
                currentSearchResult = null;
                if (listOfLXXPrimaryResults.ContainsKey(idx)) listOfLXXPrimaryResults.TryGetValue(idx, out currentSearchResult);
                globalVars.LxxBookList.TryGetValue(currentSearchResult.BookId, out currentBook);
                currentVerse = currentSearchResult.ImpactedVerse;
                rtxtReference = initialSetupOfRText(bgColour, col1Width, RightToLeft.No, noOfLines);
                flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtReference);
                rtxtText = initialSetupOfRText(bgColour, flowResults.Width - col1Width - flowSpacer, RightToLeft.No, noOfLines);
                flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtText);
                globalVars.LxxSearchText[0, noOfLines] = rtxtReference;
                globalVars.LxxSearchText[1, noOfLines++] = rtxtText;
                // Where a book name contains spaces, we don't want this split wierdly because of right-to-left text, so we use "\u3000" as a space
                referenceText = currentBook.CommonName.Replace(' ', ideographicSpace) + noBreakSpace.ToString() +
                                currentSearchResult.ChapReference + "." + currentSearchResult.VerseReference;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, referenceText);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 1, engFont);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 2, engTextColour);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 3, referenceText + ":  ");
                noOfWords = currentVerse.WordCount;
                for (wdx = 0; wdx < noOfWords; wdx++)
                {
                    currentWord = currentVerse.getWord(wdx);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, gkTextColour);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, currentWord.PreWordChars + zeroWidthSpace);
                    if (currentSearchResult.MatchingWordPositions.ContainsValue(wdx))
                    {
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, primaryFont);
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, primeMatchColour);
                    }
                    else
                    {
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, gkTextColour);
                    }
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, currentWord.TextWord);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, mainFont);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, gkTextColour);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3,
                        zeroWidthNonJoiner + currentWord.PostWordChars + currentWord.Punctuation + " ");
                }
                rtxtText.Invoke(new performRichTextBoxHeightDetermination(getNewRTXHeight), rtxtText, mainFont);
                boxHeight = noOfRTXLines;
                rtxtReference.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtReference, boxHeight);
                rtxtText.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtText, boxHeight);
            }
        }

        private void displayLXXSecondary()
        {
            const char zeroWidthSpace = '\u200b', zeroWidthNonJoiner = '\u200d', noBreakSpace = '\u00a0', ideographicSpace = '\u3000';

            int idx, bdx, primaryChap, primaryVerse, secondaryChap, secondaryVerse, noOfMatches, wdx, noOfWords = 0, noOfLines, boxHeight,
                    primaryReferenceValue, secondaryReferenceValue, index = 0, typeCode;
            String referenceText;
            FlowLayoutPanel flowResults;
            RichTextBox rtxtReference, rtxtText;
            TabControl searchTab;
            StatusStrip targetToolStrip;
            SortedList<int, classLXXSearchVerse> versesMatched = new SortedList<int, classLXXSearchVerse>();
            classLXXBook currentBook;
            classLXXChapter currentChapter;
            classLXXVerse currentVerse;
            classLXXWord currentWord;
            classLXXSearchVerse primarySearchVerse, secondarySearchVerse;
            classLXXSearchMatches currentMatch;

            Font greekFont, engFont, primaryFont, secondaryFont;
            Color engTextColour, gkTextColour, primeMatchColour, secondMatchColour, bgColour;

            targetToolStrip = (StatusStrip)globalVars.StatSearch;
            engFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(5, 1), globalVars.getDefinedStyleByIndex(5, 1), globalVars.getTextSize(5, 1));
            greekFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(5, 2), globalVars.getDefinedStyleByIndex(5, 2), globalVars.getTextSize(5, 2));
            primaryFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(5, 3), globalVars.getDefinedStyleByIndex(5, 3), globalVars.getTextSize(5, 3));
            secondaryFont = globalVars.configureFont(globalVars.getDefinedFontNameByIndex(5, 4), globalVars.getDefinedStyleByIndex(5, 4), globalVars.getTextSize(5, 4));
            searchTab = (TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 4);
            searchTab.Invoke(new performTabSelection(selectTab), searchTab, 2);
            flowResults = globalVars.FlowResults;
            flowResults.Invoke(new performPanelClear(clearFlowPanel), flowResults);
            bgColour = globalVars.getColourSetting(5, 0);
            engTextColour = globalVars.getColourSetting(5, 1);
            gkTextColour = globalVars.getColourSetting(5, 2);
            primeMatchColour = globalVars.getColourSetting(5, 3);
            secondMatchColour = globalVars.getColourSetting(5, 4);
            targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 0, "Displaying results");
            noOfMatches = noOfMatchingLXXVerses;

            for (idx = 0; idx < noOfAllMatches; idx++)
            {
                    allLXXMatches.TryGetValue(idx, out currentMatch);
                bdx = currentMatch.BookId;
                globalVars.LxxBookList.TryGetValue(bdx, out currentBook);
                primaryChap = currentMatch.PrimaryChapterSeq;
                primaryVerse = currentMatch.PrimaryVerseSeq;
                secondaryChap = currentMatch.SecondaryChapterSeq;
                secondaryVerse = currentMatch.SecondaryVerseSeq;
                primaryReferenceValue = bdx * 1000000 + primaryChap * 1000 + primaryVerse;
                secondaryReferenceValue = bdx * 1000000 + secondaryChap * 1000 + secondaryVerse;
                if (versesMatched.ContainsKey(primaryReferenceValue)) versesMatched.TryGetValue(primaryReferenceValue, out primarySearchVerse);
                else
                {
                    primarySearchVerse = new classLXXSearchVerse();
                    primarySearchVerse.BookId = bdx;
                    primarySearchVerse.ChapterNumber = primaryChap;
                    primarySearchVerse.VerseNumber = primaryVerse;
                    primarySearchVerse.ChapterReference = currentMatch.PrimaryChapterRef;
                    primarySearchVerse.VerseReference = currentMatch.PrimaryVerseRef;
                    currentChapter = currentBook.getChapterBySequence(primaryChap);
                    primarySearchVerse.ImpactedVerse = currentChapter.getVerseBySequence(primaryVerse);
                    versesMatched.Add(primaryReferenceValue, primarySearchVerse);
                }
                primarySearchVerse.addWordPosition(currentMatch.PrimaryWordSeq, 1);
                if (versesMatched.ContainsKey(secondaryReferenceValue)) versesMatched.TryGetValue(secondaryReferenceValue, out secondarySearchVerse);
                else
                {
                    secondarySearchVerse = new classLXXSearchVerse();
                    secondarySearchVerse.BookId = bdx;
                    secondarySearchVerse.ChapterNumber = secondaryChap;
                    secondarySearchVerse.VerseNumber = secondaryVerse;
                    secondarySearchVerse.ChapterReference = currentMatch.SecondaryChapterRef;
                    secondarySearchVerse.VerseReference = currentMatch.SecondaryVerseRef;
                    currentChapter = currentBook.getChapterBySequence(secondaryChap);
                    secondarySearchVerse.ImpactedVerse = currentChapter.getVerseBySequence(secondaryVerse);
                    versesMatched.Add(secondaryReferenceValue, secondarySearchVerse);
                }
                secondarySearchVerse.addWordPosition(currentMatch.SecondaryWordSeq, 2);
                if (primaryReferenceValue > secondaryReferenceValue) secondarySearchVerse.IsFollowed = true;
                else
                {
                    if (secondaryReferenceValue > primaryReferenceValue) primarySearchVerse.IsFollowed = true;
                }
            }
            // We now have information on all relevant matches
            noOfLines = 0;
            foreach (KeyValuePair<int, classLXXSearchVerse> matchPair in versesMatched)
            {
                noOfLines++;
                primarySearchVerse = matchPair.Value;
                if (!primarySearchVerse.IsFollowed) noOfLines++;
            }
            globalVars.LxxSearchText = new RichTextBox[2, noOfLines];
            globalVars.NoOfLXXResultsItems = noOfLines;
            noOfLines = 0;
            foreach (KeyValuePair<int, classLXXSearchVerse> matchPair in versesMatched)
            {
                rtxtReference = initialSetupOfRText(bgColour, col1Width, RightToLeft.No, noOfLines);
                flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtReference);
                rtxtText = initialSetupOfRText(bgColour, flowResults.Width - col1Width - flowSpacer, RightToLeft.No, noOfLines);
                flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtText);
                globalVars.LxxSearchText[0, noOfLines] = rtxtReference;
                globalVars.LxxSearchText[1, noOfLines++] = rtxtText;
                primarySearchVerse = matchPair.Value;
                currentVerse = primarySearchVerse.ImpactedVerse;
                globalVars.LxxBookList.TryGetValue(primarySearchVerse.BookId, out currentBook);
                referenceText = currentBook.CommonName.Replace(' ', ideographicSpace) + noBreakSpace.ToString() +
                                primarySearchVerse.ChapterReference + "." + primarySearchVerse.VerseReference;
                targetToolStrip.Invoke(new performToolStripMessage(displayToolStripMessage), targetToolStrip, 1, referenceText);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 1, engFont);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 2, engTextColour);
                rtxtReference.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtReference, 3, referenceText + ":  ");
                if( currentVerse == null)
                    {
                    int x = 12;
                }
                noOfWords = currentVerse.WordCount;
                for (wdx = 0; wdx < noOfWords; wdx++)
                {
                    currentWord = currentVerse.getWord(wdx);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, greekFont);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, gkTextColour);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, currentWord.PreWordChars + zeroWidthSpace);
                    if (primarySearchVerse.MatchingWordPositions.ContainsValue(wdx))
                    {
                        typeCode = 0;
                        foreach (KeyValuePair<int, int> positionPair in primarySearchVerse.MatchingWordPositions)
                        {
                            if (positionPair.Value == wdx)
                            {
                                index = positionPair.Key;
                                break;
                            }
                        }
                        primarySearchVerse.MatchingWordType.TryGetValue(index, out typeCode);
                        switch (typeCode)
                        {
                            case 0:
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, greekFont);
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, gkTextColour);
                                break;
                            case 1:
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, primaryFont);
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, primeMatchColour);
                                break;
                            case 2:
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, secondaryFont);
                                rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, secondMatchColour);
                                break;
                        }
                    }
                    else
                    {
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, greekFont);
                        rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, gkTextColour);
                    }
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3, currentWord.TextWord);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 1, greekFont);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 2, gkTextColour);
                    rtxtText.Invoke(new performRichTextBoxUpdate(updateRichTextBox), rtxtText, 3,
                        zeroWidthNonJoiner + currentWord.PostWordChars + currentWord.Punctuation + " ");
                }
                rtxtText.Invoke(new performRichTextBoxHeightDetermination(getNewRTXHeight), rtxtText, greekFont);
                boxHeight = noOfRTXLines;
                rtxtReference.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtReference, boxHeight);
                rtxtText.Invoke(new performRichTextBoxHeightAdjustment(resetRTX), rtxtText, boxHeight);
                if (!primarySearchVerse.IsFollowed)
                {
                    rtxtText = initialSetupOfRText(Color.Black, flowResults.Width - flowSpacer, RightToLeft.No, noOfLines);
                    rtxtText.Height = 5;
                    rtxtText.Visible = true;
                    rtxtText.Text = "";
                    flowResults.Invoke(new performControlPlacement(addTextBoxToPanel), flowResults, rtxtText);
                    globalVars.LxxSearchText[0, noOfLines++] = rtxtText;
                }
            }
        }

        /*======================================================================================================*
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *                                                                                                      *
         *              Methods supporting search results display common to both MT and LXX                     *
         *              ===================================================================                     *
         *                                                                                                      *
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
        /*======================================================================================================*/

        private RichTextBox initialSetupOfRText(Color backgroundColour, int colWidth, RightToLeft rightToLeft, int index)
        {
            RichTextBox rtxtCurrent;

            rtxtCurrent = new RichTextBox();
            rtxtCurrent.BackColor = backgroundColour;
            rtxtCurrent.Width = colWidth;
            rtxtCurrent.Height = 120;
            rtxtCurrent.RightToLeft = rightToLeft;
            rtxtCurrent.ContextMenuStrip = globalVars.SearchContextMenu;
            rtxtCurrent.Visible = false;
            rtxtCurrent.Tag = index;
            rtxtCurrent.MouseDown += searchResultMouseDown;
            return rtxtCurrent;
        }

        private void getNewRTXHeight(RichTextBox rtxCurrent, Font fontUsed)
        {
            int noOfLines;
            float fontHeight;

            if (rtxCurrent != null)
            {
                noOfLines = rtxCurrent.GetLineFromCharIndex(rtxCurrent.Text.Length) + 1;
                fontHeight = fontUsed.Height;
                noOfRTXLines = noOfLines * ((int)fontHeight) + rtxCurrent.Margin.Vertical;
            }
        }

        private void resetRTX(RichTextBox rtxtCurrent, int newHeight)
        {
            if (rtxtCurrent == null) return;
            rtxtCurrent.Height = newHeight;
            rtxtCurrent.Visible = true;
        }

        public void cancelSearch()
        {
            if (searchThread.IsAlive) searchThread.Abort();
        }

        /*======================================================================================================*
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         *                                                                                                      *
         *              Methods relating to search results _after_ results are displayed                        *
         *              ================================================================                        *
         *                                                                                                      *
         *  These methods are to do with either copying results or using a specific result to navigate to the   *
         *    location in the main text area.                                                                   *
         *                                                                                                      *
         *  copyAllResults                      Copy all the results currently in the search results area       *
         *  copySingleResult                    Copy the single result on which the user has clicked            *
         *  updateTextAreaWithSelectedChapter   Find and display the book and chapter on which the user clicked *
         *                                        in the main text area.                                        *
         *  searchResultMouseDown               Used to assist finding details in the above methods             *
         *                                                                                                      *
         *++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
        /*======================================================================================================*/

        public void copyAllResults(bool isToClipboard)
        {
            const char zeroWidthSpace = '\u200b', zeroWidthNonJoiner = '\u200d', noBreakSpace = '\u00a0', ideographicSpace = '\u3000';

            int versionCode, idx, noOfItems;
            String finalText = "", refText = "", verseText = "";
            RichTextBox rtxtReference, rtxtText;

            versionCode = ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 0)).SelectedIndex;
            if (versionCode == 0)
            {
                if (globalVars.MtRowIndex == -1) return;
                noOfItems = globalVars.NoOfMTResultsItems;
                for (idx = 0; idx < noOfItems; idx++)
                {
                    rtxtReference = globalVars.MtSearchText[0, idx];
                    refText = rtxtReference.Text;
                    if (refText.Length > 0)
                    {
                        rtxtText = globalVars.MtSearchText[1, idx];
                        verseText = rtxtText.Text;
                    }
                    else verseText = "";
                    if (idx == 0) finalText = refText + " " + verseText;
                    else finalText += "\n" + refText + " " + verseText;
                }
            }
            else
            {
                if (globalVars.LxxRowIndex == -1) return;
                noOfItems = globalVars.NoOfLXXResultsItems;
                for (idx = 0; idx < noOfItems; idx++)
                {
                    rtxtReference = globalVars.LxxSearchText[0, idx];
                    refText = rtxtReference.Text;
                    if (refText.Length > 0)
                    {
                        rtxtText = globalVars.LxxSearchText[1, idx];
                        verseText = rtxtText.Text;
                    }
                    else verseText = "";
                    if (idx == 0) finalText = refText + " " + verseText;
                    else finalText += "\n" + refText + " " + verseText;
                }
            }
            finalText = finalText.Replace(zeroWidthSpace.ToString(), "");
            finalText = finalText.Replace(zeroWidthNonJoiner.ToString(), "");
            finalText = finalText.Replace(noBreakSpace.ToString(), " ");
            finalText = finalText.Replace(ideographicSpace.ToString(), " ");
            if (isToClipboard)
            {
                Clipboard.SetText(finalText);
                MessageBox.Show("Search Results have been copied", "Copy to Clipboard", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                noteProcs.insertTextIntoNote(finalText);
                switch (versionCode)
                {
                    case 0: ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 5)).SelectedIndex = 0; break;
                    case 1: ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 6)).SelectedIndex = 0; break;
                }
            }
        }

        public void copySingleResult(bool isToClipboard)
        {
            const char zeroWidthSpace = '\u200b', zeroWidthNonJoiner = '\u200d', noBreakSpace = '\u00a0', ideographicSpace = '\u3000';

            int versionCode, index, startIndex;
            String finalText = "";
            RichTextBox rtxtReference, rtxtText;

            versionCode = ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 0)).SelectedIndex;
            if (versionCode == 0)
            {
                if (globalVars.MtRowIndex == -1) return;
                index = globalVars.MtRowIndex;
                // Go backwards until we reach a reference with zero-length text
                startIndex = index;
                while (startIndex >= 0)
                {
                    rtxtReference = globalVars.MtSearchText[0, startIndex];
                    if (rtxtReference.Text.Length == 0)
                    {
                        startIndex++;
                        break;
                    }
                    startIndex--;
                }
                if (startIndex < 0) startIndex = 0;
                // Now roll forward
                index = startIndex;
                while (index < globalVars.NoOfMTResultsItems)
                {
                    rtxtReference = globalVars.MtSearchText[0, index];
                    if (rtxtReference.Text.Length == 0) break;
                    rtxtText = globalVars.MtSearchText[1, index];
                    if (index == startIndex) finalText = rtxtReference.Text + " " + rtxtText.Text;
                    else finalText += "\n" + rtxtReference.Text + " " + rtxtText.Text;
                    index++;
                }
            }
            else
            {
                if (globalVars.LxxRowIndex == -1) return;
                index = globalVars.LxxRowIndex;
                // Go backwards until we reach a reference with zero-length text
                startIndex = index;
                while (startIndex >= 0)
                {
                    rtxtReference = globalVars.LxxSearchText[0, startIndex];
                    if (rtxtReference.Text.Length == 0)
                    {
                        startIndex++;
                        break;
                    }
                    startIndex--;
                }
                if (startIndex < 0) startIndex = 0;
                // Now roll forward
                index = startIndex;
                while (index < globalVars.NoOfLXXResultsItems)
                {
                    rtxtReference = globalVars.LxxSearchText[0, index];
                    if (rtxtReference.Text.Length == 0) break;
                    rtxtText = globalVars.LxxSearchText[1, index];
                    if (index == startIndex) finalText = rtxtReference.Text + " " + rtxtText.Text;
                    else finalText += "\n" + rtxtReference.Text + " " + rtxtText.Text;
                    index++;
                }
            }
            finalText = finalText.Replace(zeroWidthSpace.ToString(), "");
            finalText = finalText.Replace(zeroWidthNonJoiner.ToString(), "");
            finalText = finalText.Replace(noBreakSpace.ToString(), " ");
            finalText = finalText.Replace(ideographicSpace.ToString(), " ");
            if (isToClipboard)
            {
                Clipboard.SetText(finalText);
                MessageBox.Show("The search Result has been copied", "Copy to Clipboard", MessageBoxButtons.OK, MessageBoxIcon.Information);
            }
            else
            {
                noteProcs.insertTextIntoNote(finalText);
                switch (versionCode)
                {
                    case 0: ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 5)).SelectedIndex = 0; break;
                    case 1: ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 6)).SelectedIndex = 0; break;
                }
            }
        }

        public void updateTextAreaWithSelectedChapter()
        {
            const char zeroWidthSpace = '\u200b', zeroWidthNonJoiner = '\u200d', noBreakSpace = '\u00a0', ideographicSpace = '\u3000';

            int idx, noOfBooks = 0, versionCode, index, endPstn;
            String chapAndVerse, verseAlone, bookName = "", refString;
            classMTBook currentMTBook;
            classLXXBook currentLXXBook;
            RichTextBox rtxtReference;

            versionCode = ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 0)).SelectedIndex;
            if (versionCode == 0)
            {
                index = globalVars.MtRowIndex;
                rtxtReference = globalVars.MtSearchText[0, index];
            }
            else
            {
                index = globalVars.LxxRowIndex;
                rtxtReference = globalVars.LxxSearchText[0, index];
            }
            refString = rtxtReference.Text;
            if (refString.Length == 0) return;
            while ((refString[refString.Length - 1] == ' ') || (refString[refString.Length - 1] == ':'))
                refString = refString.Substring(0, refString.Length - 1);
            endPstn = refString.LastIndexOf(noBreakSpace);
            // So, a single space seperates the book name from chapter and verse
            chapAndVerse = refString.Substring(endPstn + 1);
            // refString becomes = book name
            refString = refString.Substring(0, endPstn);
            refString = refString.Replace(ideographicSpace.ToString(), " ");
            switch (versionCode)
            {
                case 0: noOfBooks = globalVars.NoOfMTBooks; break;
                case 1: noOfBooks = globalVars.NoOfLXXBooks; break;
            }
            idx = 0;
            while (idx < noOfBooks)
            {
                switch (versionCode)
                {
                    case 0:
                        globalVars.MtBookList.TryGetValue(idx, out currentMTBook);
                        if (currentMTBook == null)
                        {
                            idx++;
                            continue;
                        }
                        bookName = currentMTBook.BookName;
                        break;
                    case 1:
                        globalVars.LxxBookList.TryGetValue(idx, out currentLXXBook);
                        if (currentLXXBook == null)
                        {
                            idx++;
                            continue;
                        }
                        bookName = currentLXXBook.CommonName;
                        break;
                }
                if (String.Compare(bookName, refString) == 0) break;
                idx++;
            }
            endPstn = chapAndVerse.IndexOf('.');
            verseAlone = chapAndVerse.Substring(endPstn + 1);
            // Actually chapAndVerse becomes simply chap
            chapAndVerse = chapAndVerse.Substring(0, endPstn);
            switch (versionCode)
            {
                case 0: mtText.displayChapter(idx, chapAndVerse); break;
                case 1: lxxText.displayChapter(idx, chapAndVerse); break;
            }
        }

        private void searchResultMouseDown(object sender, MouseEventArgs e)
        {
            /*========================================================================================================*
             *                                                                                                        *
             *                                         searchResultMouseDown                                          *
             *                                         =====================                                          *
             *                                                                                                        *
             *  This event handler is called from *any* of the RichTextBox controls that are created in the Search    *
             *    area.  It will store the row index of the RichTextBox in which the mouse was clicked.               *
             *                                                                                                        *
             *========================================================================================================*/
            int tagVal, tabPageIndex;
            RichTextBox rtxtCurrent;

            rtxtCurrent = (RichTextBox)sender;
            if (rtxtCurrent.Text.Length == 0) tagVal = -1;
            else tagVal = Convert.ToInt32(rtxtCurrent.Tag);
            tabPageIndex = ((TabControl)globalVars.getGroupedControl(globalVars.TabControlCode, 0)).SelectedIndex;
            if (tabPageIndex == 0) globalVars.MtRowIndex = tagVal;
            if (tabPageIndex == 1) globalVars.LxxRowIndex = tagVal;
        }
    }
}
